OpenAI Codex v0.101.0 (research preview)
--------
workdir: /Users/james/Repos/wibandwob-dos
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c7260-0e83-7e92-83ea-dc24d5732969
--------
user
Round-3 comprehensive review of WibWob-DOS IPC hardening. We've just applied a large batch of fixes to the multiplayer sync layer. Please review the current state of ALL changed files and identify any remaining issues.

## What was fixed in this session
1. P0: WindowTypeRegistry (app/window_type_registry.h + .cpp) — data-driven type dispatch
2. P1: Event push (app/api_ipc.h/cpp, tools/room/partykit_bridge.py) — subscribe_events + publish_event
3. Round-2 hardening:
   - SIGPIPE protection in publish_event (MSG_NOSIGNAL / SO_NOSIGPIPE)
   - Partial write loop + backpressure drop in publish_event
   - findWindowById no longer clears winToId/idToWin maps
   - Python HMAC auth handshake in ipc_send (WIBWOB_AUTH_SECRET support)
   - IPC param percent-encoding in ipc_command
   - resize_window added to apply_delta_to_ipc
   - asyncio.Lock for last_windows in partykit_bridge.py

## Files to review
- app/api_ipc.cpp (full file — publish_event, subscribe_events, poll, auth)
- app/api_ipc.h
- app/window_type_registry.cpp (correctness of spawn wrappers + registry table)
- app/test_pattern_app.cpp (findWindowById, registerWindow, api_move/close/resize_window, windowTypeName)
- tools/room/state_diff.py (ipc_send with auth, ipc_command encoding, apply_delta_to_ipc)
- tools/room/partykit_bridge.py (event_subscribe_loop, poll_loop, receive_loop, asyncio.Lock)

## Review questions
1. Are there any remaining correctness bugs in the auth handshake (state_diff.py:_ipc_auth_handshake)?
2. Does the asyncio.Lock usage in partykit_bridge.py correctly prevent all races?
3. Are there edge cases in the publish_event partial-write loop that could cause issues?
4. Is there anything left that could cause multiplayer sync to fail silently?
5. What is the most valuable NEXT improvement? (Consider: P3 JSON dual-stack IPC, text_view spawn fix, windowTypeName registry integration, test coverage)
6. Are there any subtle issues with the event_subscribe_loop + auth handshake? (The subscribe_events command is sent to the IPC server which first runs auth. Does the Python asyncio reader handle the challenge/response correctly?)

Read the actual files. Give severity-ranked findings with exact file+line references and concrete fixes. Also indicate what is now safe/correct and no longer needs work.
mcp startup: no servers
2026-02-18T20:10:23.820912Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c67d3-e7fb-7423-879a-a3c6997f29d4
2026-02-18T20:10:23.837122Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6171-ccc2-7702-9b67-9c22338e3137
2026-02-18T20:10:23.867028Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6248-4000-77b0-815a-4015ebbba891

thinking
**Planning code review approach**
codex
I’m reviewing the exact files you listed with a code-review pass focused on correctness, race conditions, and silent-failure paths. I’ll inspect each file end-to-end, then return severity-ranked findings with concrete fixes and precise line references.
exec
/bin/zsh -lc "nl -ba app/api_ipc.cpp | sed -n '1,260p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'wc -l app/api_ipc.cpp app/api_ipc.h app/window_type_registry.cpp app/test_pattern_app.cpp tools/room/state_diff.py tools/room/partykit_bridge.py' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba app/api_ipc.cpp | sed -n '261,520p'" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
     1	#include "api_ipc.h"
     2	#include "command_registry.h"
     3	#include "window_type_registry.h"
     4	
     5	#ifndef _WIN32
     6	#include <sys/socket.h>
     7	#include <sys/stat.h>
     8	#include <sys/un.h>
     9	#include <fcntl.h>
    10	#include <unistd.h>
    11	#include <errno.h>
    12	#endif
    13	
    14	#ifdef __APPLE__
    15	#include <CommonCrypto/CommonHMAC.h>
    16	#else
    17	#include <openssl/hmac.h>
    18	#endif
    19	
    20	#include <cstring>
 succeeded in 51ms:
     637 app/api_ipc.cpp
      47 app/api_ipc.h
     194 app/window_type_registry.cpp
    3343 app/test_pattern_app.cpp
     302 tools/room/state_diff.py
     267 tools/room/partykit_bridge.py
    4790 total
 succeeded in 51ms:
   261	bool ApiIpcServer::start(const std::string& path) {
   262	#ifdef _WIN32
   263	    (void)path; return false;
   264	#else
   265	    sock_path_ = path;
   266	
   267	    // Check for existing socket file before touching it.
   268	    struct stat st;
   269	    if (::stat(sock_path_.c_str(), &st) == 0) {
   270	        if (probe_socket_live(sock_path_)) {
   271	            // Another instance is listening on this socket — do not steal it.
   272	            fprintf(stderr, "[ipc] ERROR: socket %s is already in use by another instance. "
   273	                    "Set WIBWOB_INSTANCE to a unique value or stop the other instance.\n",
   274	                    sock_path_.c_str());
   275	            return false;
   276	        }
   277	        // Stale socket (no listener) — safe to clean up.
   278	        fprintf(stderr, "[ipc] Cleaning up stale socket: %s\n", sock_path_.c_str());
   279	        ::unlink(sock_path_.c_str());
   280	    }

thinking
**Continuing code review**
codex
I’ve read the first ~520 lines of `app/api_ipc.cpp`; next I’m focusing on the remaining section where `publish_event`/`subscribe_events` are implemented and then the Python bridge files for handshake and locking details.
exec
/bin/zsh -lc "nl -ba app/api_ipc.cpp | sed -n '521,760p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba app/window_type_registry.cpp | sed -n '1,260p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba app/api_ipc.h | sed -n '1,220p'" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
   521	                            size_t pos = 0;
   522	                            while ((pos = normalized.find("\"rect\"", pos)) != std::string::npos) {
   523	                                normalized.replace(pos, 6, "\"bounds\"");
   524	                                pos += 8;
   525	                            }
   526	                        }
   527	
   528	                        std::string tmp_path = it->second + ".wwd-import-tmp.json";
   529	                        std::ofstream out(tmp_path.c_str(), std::ios::out | std::ios::trunc);
   530	                        if (!out.is_open()) {
   531	                            resp = "err cannot write import temp\n";
   532	                        } else {
   533	                            out << normalized;
   534	                            out.close();
   535	                            bool ok = api_open_workspace_path(*app_, tmp_path);
   536	                            ::unlink(tmp_path.c_str());
   537	                            fprintf(stderr, "[ipc] import_state path=%s applied=compat ok=%s\n", it->second.c_str(), ok ? "true" : "false");
   538	                            resp = ok ? "ok\n" : "err import apply failed\n";
   539	                        }
   540	                    }
 succeeded in 52ms:
     1	// Unix domain socket IPC server with optional HMAC challenge-response auth.
     2	// Protocol: cmd:<name> [key=value ...]\n
     3	// Auth: when WIBWOB_AUTH_SECRET is set, new connections must complete a
     4	//       challenge-response handshake before commands are accepted.
     5	#pragma once
     6	
     7	#include <string>
     8	#include <set>
     9	#include <vector>
    10	#include <cstdint>
    11	
    12	class TTestPatternApp;
    13	
    14	class ApiIpcServer {
    15	public:
    16	    explicit ApiIpcServer(TTestPatternApp* app);
    17	    ~ApiIpcServer();
    18	
    19	    // Start listening on a Unix socket path. Returns false on failure.
    20	    bool start(const std::string& path = "/tmp/test_pattern_app.sock");
 succeeded in 51ms:
     1	// Window type registry — single source of truth for all spawnable window types.
     2	// Keeps api_ipc.cpp free of per-type knowledge: adding a new type only requires
     3	// a new entry in the k_specs table below.
     4	
     5	#include "window_type_registry.h"
     6	
     7	// tvision for TRect
     8	#define Uses_TRect
     9	#include <tvision/tv.h>
    10	
    11	#include <cstdlib>  // atoi
    12	#include <cstring>  // strcmp
    13	
    14	// ── Extern declarations for spawn helpers in test_pattern_app.cpp ─────────────
    15	
    16	class TTestPatternApp; // forward decl (full type used only by called functions)
    17	
    18	extern void api_spawn_test(TTestPatternApp&, const TRect*);
    19	extern void api_spawn_gradient(TTestPatternApp&, const std::string&, const TRect*);
    20	extern void api_open_animation_path(TTestPatternApp&, const std::string&, const TRect*);

thinking
**Targeting test pattern search**
exec
/bin/zsh -lc "nl -ba tools/room/state_diff.py | sed -n '1,220p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba tools/room/state_diff.py | sed -n '221,380p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'rg -n "findWindowById|registerWindow|api_move_window|api_close_window|api_resize_window|windowTypeName|publish_event|unregisterWindow|idToWin|winToId" app/test_pattern_app.cpp' in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
   221	    Does not mutate the input.
   222	    """
   223	    result = dict(current)
   224	    for win in delta.get("add", []):
   225	        result[win["id"]] = win
   226	    for wid in delta.get("remove", []):
   227	        result.pop(wid, None)
   228	    for win in delta.get("update", []):
   229	        if win["id"] in result:
   230	            result[win["id"]] = {**result[win["id"]], **win}
   231	        else:
   232	            result[win["id"]] = win
   233	    return result
   234	
   235	
   236	# ── Apply remote delta to local WibWob via IPC ───────────────────────────────
   237	
   238	def _rect(win: dict) -> dict:
   239	    """Extract rect/bounds from a window dict, normalising key names.
   240	
 succeeded in 52ms:
     1	"""
     2	State diffing utilities for WibWob-DOS multiplayer sync (E008 F03).
     3	
     4	Extracts window state from IPC get_state responses, computes minimal
     5	add/remove/update deltas, and applies remote deltas to a local instance
     6	via IPC commands.
     7	
     8	Used by partykit_bridge.py and any future sync transport.
     9	"""
    10	
    11	import hashlib
    12	import hmac as _hmac
    13	import json
    14	import socket
    15	import os
    16	from typing import Any
    17	from urllib.parse import quote as _urlencode
    18	
    19	
    20	IPC_TIMEOUT = 2.0
 succeeded in 52ms:
633:    std::map<TWindow*, std::string> winToId;
634:    std::map<std::string, TWindow*> idToWin;
636:    std::string registerWindow(TWindow* w) {
638:        auto it = winToId.find(w);
639:        if (it != winToId.end()) return it->second;
643:        winToId[w] = id;
644:        idToWin[id] = w;
648:            ipcServer->publish_event("state_changed", payload);
653:    TWindow* findWindowById(const std::string& id) {
654:        auto it = idToWin.find(id);
655:        if (it != idToWin.end()) return it->second;
664:                if (w && winToId.find(w) == winToId.end()) {
669:                    winToId[w] = new_id;
670:                    idToWin[new_id] = w;
675:        it = idToWin.find(id);
676:        if (it != idToWin.end()) return it->second;
705:    friend std::string api_move_window(TTestPatternApp&, const std::string&, int, int);
706:    friend std::string api_resize_window(TTestPatternApp&, const std::string&, int, int);
708:    friend std::string api_close_window(TTestPatternApp&, const std::string&);
1239:                        registerWindow(w);
codex
I’ve moved on to the Python bridge now; I’ll verify the three-loop interaction (`event_subscribe_loop`, `poll_loop`, `receive_loop`) and whether the auth handshake framing can desynchronize reads.
exec
/bin/zsh -lc "nl -ba tools/room/partykit_bridge.py | sed -n '1,220p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba tools/room/partykit_bridge.py | sed -n '221,360p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba app/test_pattern_app.cpp | sed -n '600,760p'" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
     1	#!/usr/bin/env python3
     2	# /// script
     3	# requires-python = ">=3.11"
     4	# dependencies = ["websockets>=12"]
     5	# ///
     6	"""
     7	PartyKit bridge for WibWob-DOS multiplayer rooms (E008 F02).
     8	
     9	Runs as a sidecar alongside a WibWob instance. Polls local IPC state,
    10	diffs it, and pushes state_delta messages to PartyKit. Also receives
    11	remote deltas from PartyKit and applies them to the local instance via IPC.
    12	
    13	Usage (spawned by orchestrator):
    14	    uv run tools/room/partykit_bridge.py
    15	
    16	Environment:
    17	    WIBWOB_INSTANCE      — instance ID (e.g. "1"), drives /tmp/wibwob_1.sock
    18	    WIBWOB_PARTYKIT_URL  — PartyKit server URL (e.g. https://wibwob.user.partykit.dev)
    19	    WIBWOB_PARTYKIT_ROOM — PartyKit room/Durable Object key (e.g. "wibwob-shared")
    20	    WIBWOB_AUTH_SECRET   — shared HMAC secret for IPC auth (optional)
 succeeded in 51ms:
   221	            print("ERROR: websockets not installed. Run: uv run tools/room/partykit_bridge.py", file=sys.stderr)
   222	            return
   223	        self._state_lock = asyncio.Lock()
   224	        self.log(f"connecting to {self.ws_url}")
   225	        while True:
   226	            try:
   227	                async with ws_client.connect(self.ws_url) as ws:
   228	                    self._ws = ws
   229	                    self.log("connected")
   230	                    await asyncio.gather(
   231	                        self.poll_loop(),
   232	                        self.receive_loop(ws),
   233	                        self.event_subscribe_loop(),
   234	                    )
   235	            except Exception as e:
   236	                self._ws = None
   237	                self.log(f"disconnected ({e}), reconnecting in {RECONNECT_DELAY}s")
   238	                await asyncio.sleep(RECONNECT_DELAY)
   239	
   240	
 succeeded in 50ms:
   600	    int windowNumber;
   601	    static const int maxWindows = 99;
   602	
   603	    // Scramble cat overlay
   604	    TScrambleWindow* scrambleWindow;
   605	    ScrambleEngine scrambleEngine;
   606	    ScrambleDisplayState scrambleState;
   607	    void toggleScramble();
   608	    void toggleScrambleExpand();
   609	    void wireScrambleInput();
   610	
   611	    // Runtime API key (shared across all chat windows)
   612	    static std::string runtimeApiKey;
   613	    friend std::string getAppRuntimeApiKey();
   614	
   615	    // Kaomoji mood helper
   616	    void setKaomojiMood(TCustomMenuBar::KaomojiMood mood, int durationMs = 2000) {
   617	        if (menuBar) {
   618	            auto* customMenuBar = dynamic_cast<TCustomMenuBar*>(menuBar);
   619	            if (customMenuBar) {

thinking
**Identifying key code regions**
exec
/bin/zsh -lc "nl -ba app/test_pattern_app.cpp | sed -n '2360,2588p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba app/window_type_registry.h | sed -n '1,220p'" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
     1	// Data-driven registry mapping window type slugs to spawn callbacks.
     2	// Eliminates the if-else dispatch chain and extern declarations in api_ipc.cpp.
     3	// To add a new window type: add ONE entry in window_type_registry.cpp.
     4	#pragma once
     5	
     6	#include <string>
     7	#include <vector>
     8	#include <map>
     9	
    10	class TTestPatternApp;
    11	
    12	// Spawn callback: return nullptr on success, a static error string on failure.
    13	using WinSpawnFn = const char* (*)(TTestPatternApp&,
    14	                                   const std::map<std::string, std::string>&);
    15	
    16	struct WindowTypeSpec {
    17	    const char* type;    // canonical slug, e.g. "verse", "gradient"
    18	    WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
    19	};
    20	
 succeeded in 60ms:
  2360	    };
  2361	    std::string response = petReactions[std::rand() % 5];
  2362	
  2363	    if (app.scrambleWindow->getView()) {
  2364	        app.scrambleWindow->getView()->setPose(spDefault);
  2365	        app.scrambleWindow->getView()->say(response);
  2366	    }
  2367	    auto* msgView = app.scrambleWindow->getMessageView();
  2368	    if (msgView) msgView->addMessage("scramble", response);
  2369	    return response;
  2370	}
  2371	
  2372	std::string api_chat_receive(TTestPatternApp& app, const std::string& sender, const std::string& text) {
  2373	    // Display a remote chat message in Scramble without AI processing.
  2374	    if (!app.scrambleWindow) return "err scramble not open";
  2375	    auto* msgView = app.scrambleWindow->getMessageView();
  2376	    if (!msgView) return "err no message view";
  2377	    msgView->addMessage(sender, text);
  2378	    return "ok";
  2379	}
exec
/bin/zsh -lc 'rg -n "chat_receive|subscribe_events|auth|cmd:chat_receive|resize_window" app/api_ipc.cpp tools/room/state_diff.py tools/room/partykit_bridge.py app/test_pattern_app.cpp' in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
app/api_ipc.cpp:115:extern std::string api_resize_window(TTestPatternApp& app, const std::string& id, int width, int height);
app/api_ipc.cpp:139:    // Read auth secret from environment.
app/api_ipc.cpp:142:        auth_secret_ = secret;
app/api_ipc.cpp:143:        fprintf(stderr, "[ipc] Auth enabled (secret length=%zu)\n", auth_secret_.size());
app/api_ipc.cpp:159:           auth_secret_.data(), auth_secret_.size(),
app/api_ipc.cpp:165:         auth_secret_.data(), auth_secret_.size(),
app/api_ipc.cpp:172:bool ApiIpcServer::authenticate_connection(int fd) {
app/api_ipc.cpp:173:    if (!auth_required()) return true;
app/api_ipc.cpp:175:    // Ensure the accepted fd is blocking for the auth handshake.
app/api_ipc.cpp:189:    // Read auth response
app/api_ipc.cpp:235:    // Send auth_ok so client knows to proceed with commands.
app/api_ipc.cpp:236:    std::string ok_msg = "{\"type\":\"auth_ok\"}\n";
app/api_ipc.cpp:318:    if (auth_required()) {
app/api_ipc.cpp:319:        if (!authenticate_connection(fd)) {
app/api_ipc.cpp:320:            std::string err = "{\"error\":\"auth_failed\"}\n";
app/api_ipc.cpp:414:    } else if (cmd == "resize_window") {
app/api_ipc.cpp:421:            resp = api_resize_window(*app_, id->second, width, height) + "\n";
app/api_ipc.cpp:555:    if (cmd == "subscribe_events") {
tools/room/partykit_bridge.py:20:    WIBWOB_AUTH_SECRET   — shared HMAC secret for IPC auth (optional)
tools/room/partykit_bridge.py:129:                writer.write(b"cmd:subscribe_events\n")

thinking
**Inspecting command handling for silent failure**
exec
/bin/zsh -lc "nl -ba app/command_registry.h | sed -n '1,220p'" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'rg -n "chat_receive|resize_window|subscribe_events|create_window|exec_command" app/command_registry.* app/api_ipc.cpp' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "nl -ba app/command_registry.cpp | sed -n '1,280p'" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
     1	#pragma once
     2	
     3	#include <map>
     4	#include <string>
     5	#include <vector>
     6	
     7	class TTestPatternApp;
     8	
     9	struct CommandCapability {
    10	    const char* name;
    11	    const char* description;
    12	    bool requires_path;
    13	};
    14	
    15	const std::vector<CommandCapability>& get_command_capabilities();
    16	std::string get_command_capabilities_json();
    17	std::string exec_registry_command(
    18	    TTestPatternApp& app,
    19	    const std::string& name,
    20	    const std::map<std::string, std::string>& kv);
 succeeded in 52ms:
     1	#include "command_registry.h"
     2	
     3	#include "api_ipc.h"
     4	
     5	#include <sstream>
     6	
     7	extern void api_cascade(TTestPatternApp& app);
     8	extern void api_toggle_scramble(TTestPatternApp& app);
     9	extern void api_expand_scramble(TTestPatternApp& app);
    10	extern std::string api_scramble_say(TTestPatternApp& app, const std::string& text);
    11	extern std::string api_scramble_pet(TTestPatternApp& app);
    12	extern std::string api_chat_receive(TTestPatternApp& app, const std::string& sender, const std::string& text);
    13	extern void api_tile(TTestPatternApp& app);
    14	extern void api_close_all(TTestPatternApp& app);
    15	extern void api_save_workspace(TTestPatternApp& app);
    16	extern bool api_open_workspace_path(TTestPatternApp& app, const std::string& path);
    17	extern void api_screenshot(TTestPatternApp& app);
    18	extern void api_set_pattern_mode(TTestPatternApp& app, const std::string& mode);
    19	extern std::string api_set_theme_mode(TTestPatternApp& app, const std::string& mode);
    20	extern std::string api_set_theme_variant(TTestPatternApp& app, const std::string& variant);
 succeeded in 52ms:
app/api_ipc.cpp:115:extern std::string api_resize_window(TTestPatternApp& app, const std::string& id, int width, int height);
app/api_ipc.cpp:360:    } else if (cmd == "exec_command") {
app/api_ipc.cpp:367:    } else if (cmd == "create_window") {
app/api_ipc.cpp:414:    } else if (cmd == "resize_window") {
app/api_ipc.cpp:421:            resp = api_resize_window(*app_, id->second, width, height) + "\n";
app/api_ipc.cpp:555:    if (cmd == "subscribe_events") {
app/command_registry.cpp:12:extern std::string api_chat_receive(TTestPatternApp& app, const std::string& sender, const std::string& text);
app/command_registry.cpp:39:        {"chat_receive", "Display a remote chat message in Scramble (sender + text params)", true},
app/command_registry.cpp:146:    if (name == "chat_receive") {
app/command_registry.cpp:152:        return api_chat_receive(app, sender, itText->second);

thinking
**Identifying multiple subtle IPC and sync bugs**
exec
/bin/zsh -lc 'rg -n "resize_window|subscribe_events|_ipc_auth_handshake|state_delta|apply_delta_to_ipc|chat_receive" tools/room app | head -n 200' in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
tools/room/partykit_bridge.py:10:diffs it, and pushes state_delta messages to PartyKit. Also receives
tools/room/partykit_bridge.py:34:    apply_delta_to_ipc,
tools/room/partykit_bridge.py:85:        msg = json.dumps({"type": "state_delta", "delta": delta})
tools/room/partykit_bridge.py:129:                writer.write(b"cmd:subscribe_events\n")
tools/room/partykit_bridge.py:189:                            apply_delta_to_ipc(self.sock_path, delta)
tools/room/partykit_bridge.py:196:            elif mtype == "state_delta":
tools/room/partykit_bridge.py:199:                    applied = apply_delta_to_ipc(self.sock_path, delta)
tools/room/partykit_bridge.py:215:                    ipc_command(self.sock_path, "chat_receive", {"sender": sender, "text": text})
tools/room/state_diff.py:28:def _ipc_auth_handshake(s: socket.socket) -> bool:
tools/room/state_diff.py:78:        if not _ipc_auth_handshake(s):
tools/room/state_diff.py:252:def apply_delta_to_ipc(sock_path: str, delta: dict[str, Any]) -> list[str]:
tools/room/state_diff.py:254:    Apply a remote state_delta to a local WibWob instance via IPC.
tools/room/state_diff.py:296:                ok = ipc_command(sock_path, "resize_window", {
tools/room/state_diff.py:299:                tag = f"resize_window id={wid} w={w} h={h}"
app/command_registry.cpp:12:extern std::string api_chat_receive(TTestPatternApp& app, const std::string& sender, const std::string& text);
app/command_registry.cpp:39:        {"chat_receive", "Display a remote chat message in Scramble (sender + text params)", true},
app/command_registry.cpp:146:    if (name == "chat_receive") {
app/command_registry.cpp:152:        return api_chat_receive(app, sender, itText->second);
app/api_ipc.cpp:115:extern std::string api_resize_window(TTestPatternApp& app, const std::string& id, int width, int height);
app/api_ipc.cpp:414:    } else if (cmd == "resize_window") {

thinking
**Summarizing core protocol findings**
codex
**Findings (severity-ranked)**

1. **Critical: `event_subscribe_loop` does not perform auth handshake, so event push breaks whenever `WIBWOB_AUTH_SECRET` is set.**  
`tools/room/partykit_bridge.py:128-131` sends `cmd:subscribe_events` immediately.  
Server requires challenge/response first (`app/api_ipc.cpp:184-205`, `app/api_ipc.cpp:317-324`).  
Result: subscription fails/reconnect loops, real-time sync degrades to slow polling.  
**Fix:** implement async handshake for `StreamReader/StreamWriter` before sending subscribe command.

2. **High: resize updates are still broken due to parameter name mismatch.**  
`tools/room/state_diff.py:296-299` sends `w`/`h` for `resize_window`.  
Server expects `width`/`height` (`app/api_ipc.cpp:416-423`).  
Result: remote resize deltas fail.  
**Fix:** send `{"id": wid, "width": w, "height": h}`.

3. **High: lock usage still leaves a race in `state_delta` apply path.**  
`tools/room/partykit_bridge.py:198-206` calls `apply_delta_to_ipc` outside `_state_lock`; meanwhile `poll_loop`/`event_subscribe_loop` can interleave and push stale/transient diffs.  
**Fix:** hold `_state_lock` across remote apply + baseline refresh (or introduce “suppress outbound while applying remote delta”).

4. **Medium: remote chat apply path likely fails (and is currently silent).**  
Bridge sends `cmd:chat_receive` (`tools/room/partykit_bridge.py:215`), but direct IPC command parser has no `chat_receive` branch (`app/api_ipc.cpp:358-552`). `chat_receive` exists only via `exec_command` registry (`app/command_registry.cpp:146-153`).  
**Fix:** either send `cmd:exec_command name=chat_receive sender=... text=...` or add direct `chat_receive` handling in `api_ipc.cpp`; also check/log failure return.

5. **Medium: `publish_event` drops subscribers on `EINTR`.**  
`app/api_ipc.cpp:603-610` treats all non-EAGAIN errors as fatal.  
**Fix:** if `errno == EINTR`, continue write loop.

6. **Low: auth read is single-shot and can fail on partial frame.**  
`app/api_ipc.cpp:190-198` reads once instead of line-framing until newline.  
**Fix:** read in a loop until `\n` or timeout.

---

**Answers to your review questions**

1. **Auth handshake correctness (`_ipc_auth_handshake`)**: good for request/response IPC sockets, but real break is not here; it’s missing from async subscription path.  
2. **`asyncio.Lock` completeness**: improved, but not complete; `state_delta` apply is still outside lock.  
3. **`publish_event` partial-write edge cases**: mostly solid now (non-blocking + backpressure drop + SIGPIPE mitigation), but `EINTR` handling is missing.  
4. **Silent multiplayer sync failure risks**: yes: resize mismatch, subscription auth mismatch, and ignored chat command failure.  
5. **Most valuable next improvement**: **P3 JSON dual-stack IPC** (single framed schema for auth/commands/events) because it eliminates key-name drift (`w/h` vs `width/height`) and mixed protocol handling bugs.  
6. **`event_subscribe_loop` + auth handshake subtlety**: currently incorrect; reader/writer must consume challenge, send HMAC, read `auth_ok`, then send `subscribe_events`.

---

**What is now safe/correct**

- `findWindowById` no longer clears ID maps (good stability fix): `app/test_pattern_app.cpp:657-677`.  
- `publish_event` now handles partial writes and backpressure drop strategy (good anti-stall behavior): `app/api_ipc.cpp:595-616`.  
- SIGPIPE hardening is in place (`MSG_NOSIGNAL` / `SO_NOSIGPIPE`): `app/api_ipc.cpp:559-562`, `app/api_ipc.cpp:589-599`.  
- IPC percent-encoding/decoding path is correctly wired end-to-end: `tools/room/state_diff.py:107-121`, `app/api_ipc.cpp:351`.  
- Data-driven window type dispatch is structurally correct and cleaner: `app/window_type_registry.cpp:157-194`.
tokens used
40,087
**Findings (severity-ranked)**

1. **Critical: `event_subscribe_loop` does not perform auth handshake, so event push breaks whenever `WIBWOB_AUTH_SECRET` is set.**  
`tools/room/partykit_bridge.py:128-131` sends `cmd:subscribe_events` immediately.  
Server requires challenge/response first (`app/api_ipc.cpp:184-205`, `app/api_ipc.cpp:317-324`).  
Result: subscription fails/reconnect loops, real-time sync degrades to slow polling.  
**Fix:** implement async handshake for `StreamReader/StreamWriter` before sending subscribe command.

2. **High: resize updates are still broken due to parameter name mismatch.**  
`tools/room/state_diff.py:296-299` sends `w`/`h` for `resize_window`.  
Server expects `width`/`height` (`app/api_ipc.cpp:416-423`).  
Result: remote resize deltas fail.  
**Fix:** send `{"id": wid, "width": w, "height": h}`.

3. **High: lock usage still leaves a race in `state_delta` apply path.**  
`tools/room/partykit_bridge.py:198-206` calls `apply_delta_to_ipc` outside `_state_lock`; meanwhile `poll_loop`/`event_subscribe_loop` can interleave and push stale/transient diffs.  
**Fix:** hold `_state_lock` across remote apply + baseline refresh (or introduce “suppress outbound while applying remote delta”).

4. **Medium: remote chat apply path likely fails (and is currently silent).**  
Bridge sends `cmd:chat_receive` (`tools/room/partykit_bridge.py:215`), but direct IPC command parser has no `chat_receive` branch (`app/api_ipc.cpp:358-552`). `chat_receive` exists only via `exec_command` registry (`app/command_registry.cpp:146-153`).  
**Fix:** either send `cmd:exec_command name=chat_receive sender=... text=...` or add direct `chat_receive` handling in `api_ipc.cpp`; also check/log failure return.

5. **Medium: `publish_event` drops subscribers on `EINTR`.**  
`app/api_ipc.cpp:603-610` treats all non-EAGAIN errors as fatal.  
**Fix:** if `errno == EINTR`, continue write loop.

6. **Low: auth read is single-shot and can fail on partial frame.**  
`app/api_ipc.cpp:190-198` reads once instead of line-framing until newline.  
**Fix:** read in a loop until `\n` or timeout.

---

**Answers to your review questions**

1. **Auth handshake correctness (`_ipc_auth_handshake`)**: good for request/response IPC sockets, but real break is not here; it’s missing from async subscription path.  
2. **`asyncio.Lock` completeness**: improved, but not complete; `state_delta` apply is still outside lock.  
3. **`publish_event` partial-write edge cases**: mostly solid now (non-blocking + backpressure drop + SIGPIPE mitigation), but `EINTR` handling is missing.  
4. **Silent multiplayer sync failure risks**: yes: resize mismatch, subscription auth mismatch, and ignored chat command failure.  
5. **Most valuable next improvement**: **P3 JSON dual-stack IPC** (single framed schema for auth/commands/events) because it eliminates key-name drift (`w/h` vs `width/height`) and mixed protocol handling bugs.  
6. **`event_subscribe_loop` + auth handshake subtlety**: currently incorrect; reader/writer must consume challenge, send HMAC, read `auth_ok`, then send `subscribe_events`.

---

**What is now safe/correct**

- `findWindowById` no longer clears ID maps (good stability fix): `app/test_pattern_app.cpp:657-677`.  
- `publish_event` now handles partial writes and backpressure drop strategy (good anti-stall behavior): `app/api_ipc.cpp:595-616`.  
- SIGPIPE hardening is in place (`MSG_NOSIGNAL` / `SO_NOSIGPIPE`): `app/api_ipc.cpp:559-562`, `app/api_ipc.cpp:589-599`.  
- IPC percent-encoding/decoding path is correctly wired end-to-end: `tools/room/state_diff.py:107-121`, `app/api_ipc.cpp:351`.  
- Data-driven window type dispatch is structurally correct and cleaner: `app/window_type_registry.cpp:157-194`.
