OpenAI Codex v0.101.0 (research preview)
--------
workdir: /Users/james/Repos/wibandwob-dos
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c7286-5118-7281-a418-ade288cdc3ff
--------
user
Read CODEX-ARCH-REVIEW-20260218.md and CODEX-ANALYSIS-ROUND8-REVIEW.md for full context on where the E008 multiplayer sync codebase stands after 8 rounds of hardening.

The multiplayer sync code is now robust (all Critical/High bugs fixed across rounds 2-8, 156 tests passing). The next phase is architecture-level improvements from CODEX-ARCH-REVIEW-20260218.md.

Please implement the following prioritised fixes in order:

## Fix 1 (High): Orchestrator bridge process leak
File: tools/room/orchestrator.py

The bridge Popen handles are spawned but never tracked or terminated in stop_room/stop_all. Also ttyd stdout/stderr are piped to PIPE but never drained (deadlock risk under heavy output).

Tasks:
- Read orchestrator.py fully to understand RoomProcess and spawn_room/stop_room/stop_all
- Store bridge Popen handles in RoomProcess (alongside the ttyd handle)
- In stop_room: terminate and wait bridge processes
- In stop_all: same
- Redirect ttyd stdout/stderr to subprocess.DEVNULL (not PIPE) to eliminate deadlock

## Fix 2 (High): windowTypeName ↔ window_type_registry desync risk
File: app/window_type_registry.h/.cpp and app/test_pattern_app.cpp

The type slug is currently defined twice: once in k_specs[] in window_type_registry.cpp, and once separately in windowTypeName() in test_pattern_app.cpp via dynamic_cast chains. If they diverge, multiplayer silently breaks.

Tasks:
- Add a  function pointer to WindowTypeSpec (takes TWindow*, returns bool)
- Implement matches lambdas for each type in k_specs (using dynamic_cast or HAS_CHILD_VIEW pattern)
- Replace windowTypeName() in test_pattern_app.cpp with a loop over all_window_type_specs() calling spec.matches(w) to find the type slug — single source of truth

## Fix 3 (Medium): registerWindow side-effect during api_get_state reads
File: app/test_pattern_app.cpp

registerWindow() publishes 'state_changed' (line ~651), but api_get_state calls registerWindow for every active window (line ~2475). A read operation emitting write-side-effects is dangerous.

Tasks:
- Add a bool parameter to registerWindow: registerWindow(TWindow* w, bool emit_event = true)
- In api_get_state loop, call registerWindow(w, false) — assigns ID silently, no state_changed emission
- Real registrations (window opened) still call registerWindow(w, true)

For each fix:
- Read the actual file before editing
- Build with cmake --build ./build after each fix
- Run uv run --with pytest pytest tests/room/ -q after Python changes
- Commit with fix(scope): message format

After all fixes, run a final Codex verification round:
codex exec -C /Users/james/Repos/wibandwob-dos 'Read CODEX-ARCH-REVIEW-20260218.md. Verify the 3 fixes above were correctly implemented (orchestrator bridge lifecycle, windowTypeName single source, registerWindow side-effect). Report any remaining issues.' 2>&1 | tee codex-arch-fixes-verification-20260218.log
mcp startup: no servers
2026-02-18T20:52:11.214296Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c67d3-e7fb-7423-879a-a3c6997f29d4
2026-02-18T20:52:11.249232Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6171-ccc2-7702-9b67-9c22338e3137
2026-02-18T20:52:11.264853Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6248-4000-77b0-815a-4015ebbba891

thinking
**Acknowledging task and planning edits**
codex
I’ll implement the three fixes in order and verify after each one exactly as requested. First I’m reading the target files and current architecture-review notes so I can patch against the real code paths safely.
exec
/bin/zsh -lc "sed -n '260,620p' tools/room/orchestrator.py" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '1,260p' tools/room/orchestrator.py" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'rg --files CODEX-ARCH-REVIEW-20260218.md CODEX-ANALYSIS-ROUND8-REVIEW.md tools/room/orchestrator.py app/window_type_registry.h app/window_type_registry.cpp app/test_pattern_app.cpp' in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
                    if room and room.restart_count < 5:
                        self.restart_room(room_id)
                    elif room:
                        print(f"[orch] {room_id} exceeded max restarts (5), leaving stopped.")

        self.stop_all()
        if self._state_file.exists():
            self._state_file.unlink()
        print("[orch] Shutdown complete.")


def cmd_start(args):
    """Start rooms from config files."""
    orch = Orchestrator()
    config_paths = [Path(p) for p in args.configs]
    configs = orch.load_configs(config_paths)

    if not configs:
        print("[orch] No valid configs found.", file=sys.stderr)
        sys.exit(1)
 succeeded in 52ms:
#!/usr/bin/env python3
"""Room orchestrator for WibWob-DOS teleport rooms.

Reads room configs (markdown + YAML frontmatter), spawns ttyd+WibWob
instance pairs, manages lifecycle (health check, restart on failure),
generates shared secrets for agent auth.

Usage:
    ./tools/room/orchestrator.py start rooms/*.md
    ./tools/room/orchestrator.py stop
    ./tools/room/orchestrator.py status
"""

import argparse
import json
import os
import secrets
import signal
import socket
import subprocess
 succeeded in 51ms:
app/window_type_registry.h
app/window_type_registry.cpp
tools/room/orchestrator.py
CODEX-ANALYSIS-ROUND8-REVIEW.md
CODEX-ARCH-REVIEW-20260218.md
app/test_pattern_app.cpp
codex
I’ve confirmed the orchestrator leak and `PIPE` usage in `spawn_room`. Next I’m reading the window type registry and `windowTypeName`/`registerWindow` call sites to apply fixes 2 and 3 without breaking existing behavior.
exec
/bin/zsh -lc "sed -n '1,260p' app/window_type_registry.h" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '1,360p' app/window_type_registry.cpp" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "rg -n \"windowTypeName|registerWindow\\(|all_window_type_specs|WindowTypeSpec|api_get_state\" app/test_pattern_app.cpp app/window_type_registry.*" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
// Data-driven registry mapping window type slugs to spawn callbacks.
// Eliminates the if-else dispatch chain and extern declarations in api_ipc.cpp.
// To add a new window type: add ONE entry in window_type_registry.cpp.
#pragma once

#include <string>
#include <vector>
#include <map>

class TTestPatternApp;

// Spawn callback: return nullptr on success, a static error string on failure.
using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                   const std::map<std::string, std::string>&);

struct WindowTypeSpec {
    const char* type;    // canonical slug, e.g. "verse", "gradient"
    WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
};

 succeeded in 51ms:
// Window type registry — single source of truth for all spawnable window types.
// Keeps api_ipc.cpp free of per-type knowledge: adding a new type only requires
// a new entry in the k_specs table below.

#include "window_type_registry.h"

// tvision for TRect
#define Uses_TRect
#include <tvision/tv.h>

#include <cstdlib>  // atoi
#include <cstring>  // strcmp

// ── Extern declarations for spawn helpers in test_pattern_app.cpp ─────────────

class TTestPatternApp; // forward decl (full type used only by called functions)

extern void api_spawn_test(TTestPatternApp&, const TRect*);
extern void api_spawn_gradient(TTestPatternApp&, const std::string&, const TRect*);
extern void api_open_animation_path(TTestPatternApp&, const std::string&, const TRect*);
 succeeded in 51ms:
app/window_type_registry.cpp:157:static const WindowTypeSpec k_specs[] = {
app/window_type_registry.cpp:184:const std::vector<WindowTypeSpec>& all_window_type_specs() {
app/window_type_registry.cpp:185:    static std::vector<WindowTypeSpec> specs(
app/window_type_registry.cpp:190:const WindowTypeSpec* find_window_type_by_name(const std::string& name) {
app/window_type_registry.cpp:191:    for (const auto& spec : all_window_type_specs())
app/window_type_registry.h:16:struct WindowTypeSpec {
app/window_type_registry.h:22:const WindowTypeSpec* find_window_type_by_name(const std::string& name);
app/window_type_registry.h:25:const std::vector<WindowTypeSpec>& all_window_type_specs();
app/test_pattern_app.cpp:642:    std::string registerWindow(TWindow* w) {
app/test_pattern_app.cpp:710:    friend std::string api_get_state(TTestPatternApp&);
app/test_pattern_app.cpp:1245:                        registerWindow(w);
app/test_pattern_app.cpp:1300:    registerWindow(window);
app/test_pattern_app.cpp:1309:    registerWindow(window);
app/test_pattern_app.cpp:1318:    registerWindow(window);
app/test_pattern_app.cpp:1562:    registerWindow(window);
app/test_pattern_app.cpp:1590:    registerWindow(window);
app/test_pattern_app.cpp:1612://     registerWindow(window);
app/test_pattern_app.cpp:1634:    registerWindow(window);
app/test_pattern_app.cpp:1661:    registerWindow(window);
app/test_pattern_app.cpp:1687:    registerWindow(window);

thinking
**Inspecting test pattern classes**
exec
/bin/zsh -lc "sed -n '560,760p' app/test_pattern_app.cpp" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '1,260p' app/test_pattern_app.cpp" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '2360,2525p' app/test_pattern_app.cpp" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:

    if (app.scrambleWindow->getView()) {
        app.scrambleWindow->getView()->setPose(spDefault);
        app.scrambleWindow->getView()->say(response);
    }
    auto* msgView = app.scrambleWindow->getMessageView();
    if (msgView) msgView->addMessage("scramble", response);
    return response;
}

std::string api_chat_receive(TTestPatternApp& app, const std::string& sender, const std::string& text) {
    // Display a remote chat message in Scramble without AI processing.
    if (!app.scrambleWindow) return "err scramble not open";
    auto* msgView = app.scrambleWindow->getMessageView();
    if (!msgView) return "err no message view";
    msgView->addMessage(sender, text);
    return "ok";
}

void api_tile(TTestPatternApp& app) { app.tile(); }
 succeeded in 52ms:
    virtual TPalette& getPalette() const;
    static TMenuBar* initMenuBar(TRect);
    static TStatusLine* initStatusLine(TRect);
    static TDeskTop* initDeskTop(TRect);
    
private:
    void newTestWindow();
    void newTestWindow(const TRect& bounds);
    void newGradientWindow(TGradientWindow::GradientType type);
    void newGradientWindow(TGradientWindow::GradientType type, const TRect& bounds);
    // void newMechWindow();
    void newDonutWindow();
    void newBrowserWindow();
    void newBrowserWindow(const TRect& bounds);
    void newWibWobWindow();
    void newWibWobTestWindowA();
    void newWibWobTestWindowB();
    void newWibWobTestWindowC();
    void openAnimationFile();
    void openAnimationFilePath(const std::string& path);
 succeeded in 52ms:
/*---------------------------------------------------------*/
/*                                                         */
/*   test_pattern_app.cpp - Test Pattern Window Spawner   */
/*   Unlimited resizable windows with test patterns       */
/*                                                         */
/*---------------------------------------------------------*/

#define Uses_TKeys
#define Uses_TApplication
#define Uses_TEvent
#define Uses_TRect
#define Uses_TDialog
#define Uses_TStaticText
#define Uses_TButton
#define Uses_TMenuBar
#define Uses_TSubMenu
#define Uses_TMenuItem
#define Uses_TMenu
#define Uses_TStatusLine
#define Uses_TStatusItem

thinking
**Checking registry header inclusion**
exec
/bin/zsh -lc 'rg -n "window_type_registry" app/test_pattern_app.cpp' in /Users/james/Repos/wibandwob-dos exited 1 in 51ms:


thinking
**Assessing type availability for dynamic casts**
codex
I found `windowTypeName` is currently standalone in `app/test_pattern_app.cpp`; I’m now checking where each window/view class is actually declared so the registry can own the match logic without introducing invalid casts.
exec
/bin/zsh -lc "sed -n '1,220p' app/browser_view.h" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '1,220p' app/text_editor_view.h" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'rg -n "class T(TestPatternWindow|GradientWindow|FrameAnimationWindow|TransparentTextWindow|TextEditorWindow|BrowserWindow|WibWobWindow|ScrambleWindow|AnimatedHGradientView|AnimatedBlocksView|AnimatedScoreView|AnimatedAsciiView|GenerativeVerseView|GenerativeMyceliumView|GenerativeOrbitView|GenerativeTorusView|GenerativeCubeView|GameOfLifeView|GenerativeMonsterCamView|GenerativeMonsterVerseView|GenerativeMonsterPortalView)" app/*.h app/*.cpp' in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
/*---------------------------------------------------------*/
/*                                                         */
/*   text_editor_view.h - API-Controllable Text Editor    */
/*                                                         */
/*   Multi-line text editor that can receive content      */
/*   via API calls for dynamic text/ASCII art display     */
/*                                                         */
/*---------------------------------------------------------*/

#ifndef TEXT_EDITOR_VIEW_H
#define TEXT_EDITOR_VIEW_H

#define Uses_TView
#define Uses_TRect
#define Uses_TDrawBuffer
#define Uses_TEvent
#define Uses_TColorAttr
#define Uses_TScrollBar
#define Uses_TWindow
#define Uses_TFrame
 succeeded in 52ms:
/*---------------------------------------------------------*/
/*                                                         */
/*   browser_view.h - TUI Browser Window                   */
/*   Fetches URLs via Python API, renders markdown text    */
/*                                                         */
/*---------------------------------------------------------*/

#ifndef BROWSER_VIEW_H
#define BROWSER_VIEW_H

#define Uses_TView
#define Uses_TRect
#define Uses_TEvent
#define Uses_TKeys
#define Uses_TDrawBuffer
#define Uses_TWindow
#define Uses_TFrame
#define Uses_TScrollBar
#define Uses_TScroller
#include <tvision/tv.h>
 succeeded in 50ms:
app/animated_gradient_view.h:18:class TAnimatedHGradientView : public TView {
app/animated_ascii_view.h:20:class TAnimatedAsciiView : public TView {
app/animated_score_view.h:28:class TAnimatedScoreView : public TView {
app/animated_blocks_view.h:19:class TAnimatedBlocksView : public TView {
app/browser_view.h:74:class TBrowserWindow : public TWindow {
app/generative_cube_view.h:20:class TGenerativeCubeView : public TView {
app/game_of_life_view.h:41:class TGameOfLifeView : public TView {
app/generative_mycelium_view.h:19:class TGenerativeMyceliumView : public TView {
app/generative_verse_view.h:21:class TGenerativeVerseView : public TView {
app/generative_orbit_view.h:20:class TGenerativeOrbitView : public TView {
app/generative_monster_cam_view.h:23:class TGenerativeMonsterCamView : public TView {
app/generative_monster_portal_view.h:21:class TGenerativeMonsterPortalView : public TView {
app/generative_torus_view.h:20:class TGenerativeTorusView : public TView {
app/generative_monster_verse_view.h:20:class TGenerativeMonsterVerseView : public TView {
app/text_editor_view.h:83:class TTextEditorWindow : public TWindow {
app/transparent_text_view.h:65:class TTransparentTextWindow : public TWindow
app/scramble_view.h:179:class TScrambleWindow : public TWindow
app/wibwob_view.h:30:class TWibWobWindow;
app/wibwob_view.h:139:class TWibWobWindow : public TWindow {
app/test_pattern_app.cpp:221:class TTestPatternWindow;

thinking
**Assessing class placement for view components**
exec
/bin/zsh -lc "sed -n '1,220p' app/test_pattern.h" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
/*---------------------------------------------------------*/
/*                                                         */
/*   test_pattern.h - Reusable Test Pattern Module        */
/*   For Turbo Vision Applications                        */
/*                                                         */
/*---------------------------------------------------------*/

#ifndef TEST_PATTERN_H
#define TEST_PATTERN_H

#define Uses_TDrawBuffer
#define Uses_TColorAttr
#include <tvision/tv.h>

class TTestPattern
{
public:
    // Pattern display modes
    enum PatternMode {
        pmTiled,        // Pattern resets at start of each row (cropped at edges)

thinking
**Assessing window matching logic**
exec
/bin/zsh -lc "sed -n '360,560p' app/test_pattern_app.cpp" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
            case 1:  // Try index 1
            case 2:  // Try index 2  
            case 3:  // Try index 3
            case 4:  // Try index 4
                return TColorAttr(trueBlack, trueWhite);  // BLACK ON TRUE WHITE
            default:
                return TStatusLine::mapColor(index);  // Use parent's mapping for others
        }
    }
};

/*---------------------------------------------------------*/
/* TTestPatternView - The interior view showing pattern   */
/*---------------------------------------------------------*/
class TTestPatternView : public TView
{
    
public:
    TTestPatternView(const TRect& bounds) : TView(bounds)
    {

thinking
**Planning window type matching logic**
exec
/bin/zsh -lc "sed -n '1,260p' app/frame_file_player_view.h" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
/*---------------------------------------------------------*/
/*                                                         */
/*   frame_file_player_view.h - ASCII frame-file player   */
/*                                                         */
/*   How it works (MVP):                                  */
/*   - Loads a text file once into 'fileData'.            */
/*   - Builds 'frames' as byte spans split by lines       */
/*     exactly equal to "----" (CRLF safe).               */
/*   - Starts a periodic UI timer; on each tick advances  */
/*     'frameIndex' and requests redraw (no threads).     */
/*   - draw(): blits current frame, truncating/padding to */
/*     view width/height.                                 */
/*   - FPS sources (precedence): ctor param > header >    */
/*     default (300 ms).                                   */
/*                                                         */
/*---------------------------------------------------------*/

#ifndef FRAME_FILE_PLAYER_VIEW_H
#define FRAME_FILE_PLAYER_VIEW_H


thinking
**Identifying gradient view definitions**
exec
/bin/zsh -lc "sed -n '1,260p' app/gradient.h" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
/*---------------------------------------------------------*/
/*                                                         */
/*   gradient.h - Gradient Rendering Views                */
/*   For Turbo Vision Applications                        */
/*                                                         */
/*---------------------------------------------------------*/

#ifndef GRADIENT_H
#define GRADIENT_H

#define Uses_TView
#define Uses_TRect
#define Uses_TDrawBuffer
#define Uses_TColorAttr
#include <tvision/tv.h>
#include <cmath>

/*---------------------------------------------------------*/
/* TGradientView - Base class for gradient rendering      */
/*---------------------------------------------------------*/

thinking
**Preparing test coverage inspection**
exec
/bin/zsh -lc "sed -n '1,220p' CODEX-ARCH-REVIEW-20260218.md" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '1,220p' CODEX-ANALYSIS-ROUND8-REVIEW.md" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
# Codex Round-8 Review: Final Verification Pass

**Raw log**: `codex-review-round8-20260218.log`
**Token cost**: ~74,000
**Model**: gpt-5.3-codex

## Context

Final comprehensive sweep after rounds 3-7 fixes. Asked Codex to focus on
remaining subtle issues: partial update logic, t.exception() safety, writer
cleanup, percent-decoding, title churn, reconnect state.

## Findings

| # | Severity | Finding |
|---|----------|---------|
| 1 | Low | `_rect()` doesn't recurse through double-nested rect dicts — not produced by current PartyKit flow |

## All Clean (explicit verification)

 succeeded in 52ms:
# Codex Architecture Review — 2026-02-18

**Raw log**: `codex-arch-review-20260218.log`
**Token cost**: ~93,000
**Model**: gpt-5.3-codex

## Scope

Top-level architecture, DRY, C++14/Turbo Vision practices, Python best practices, naming, documentation.

## Findings

| # | Severity | Area | Finding |
|---|----------|------|---------|
| 1 | High | Orchestrator | `ttyd` stdout/stderr piped but never drained → pipe buffer deadlock risk; bridge Popen handles not tracked/stopped |
| 2 | High | C++ IPC | Dual dispatch: `exec_command` (registry) AND giant if/else in `api_ipc.cpp:365` — parity drift risk |
| 3 | High | C++ | Window type identity split: `windowTypeName()` and `window_type_registry.cpp` are independent — silent desync risk |
| 4 | Medium | C++ | `registerWindow()` publishes `state_changed` → `api_get_state` (a read) can emit write-side effects |
| 5 | Medium | C++ | `ipcServer` raw `new`, no `TTestPatternApp` destructor → depends on process teardown not RAII |
| 6 | Medium | Python | Blocking `ipc_get_state`/`apply_delta_to_ipc` called inside async coroutines → stalls event loop on timeout |

thinking
**Providing detailed plan**
codex
Plan for this pass:

1. Fix orchestrator lifecycle in `tools/room/orchestrator.py`:
- Extend `RoomProcess` to track bridge `Popen` handles.
- Start `ttyd` with `stdout/stderr=DEVNULL`.
- Track bridge process on spawn and terminate/kill+wait it during `stop_room` and `stop_all` paths.

2. Build and Python-room tests after Fix 1:
- `cmake --build ./build`
- `uv run --with pytest pytest tests/room/ -q`
- Commit with `fix(room): ...`.

3. Fix window-type source-of-truth in C++:
- Add `matches` function pointer to `WindowTypeSpec` in `app/window_type_registry.h`.
- Implement match functions in `app/window_type_registry.cpp` for every registry entry (direct window casts where available, child-view probing otherwise).
- Replace `windowTypeName()` logic in `app/test_pattern_app.cpp` with a registry scan using `all_window_type_specs()`.

4. Build after Fix 2 and commit:
- `cmake --build ./build`
- Commit with `fix(registry): ...`.

5. Fix `registerWindow` read side-effect:
- Change signature to `registerWindow(TWindow* w, bool emit_event = true)`.
- Use `registerWindow(w, false)` inside `api_get_state`.
- Build after Fix 3 and commit with `fix(api): ...`.

6. Run final verification command and capture log:
- `codex exec -C /Users/james/Repos/wibandwob-dos 'Read CODEX-ARCH-REVIEW-20260218.md. Verify the 3 fixes above were correctly implemented (orchestrator bridge lifecycle, windowTypeName single source, registerWindow side-effect). Report any remaining issues.' 2>&1 | tee codex-arch-fixes-verification-20260218.log`

thinking
**Fixing process lifecycle and bridge leaks**
codex
I’m editing `tools/room/orchestrator.py` now to track bridge processes, terminate them on room shutdown/restart, and switch `ttyd` I/O to `DEVNULL` to remove the pipe-backpressure deadlock path.
file update
M /Users/james/Repos/wibandwob-dos/tools/room/orchestrator.py
@@ -38,2 +38,3 @@
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
@@ -115,4 +116,4 @@
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
@@ -134,8 +135,11 @@
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
@@ -144,2 +148,15 @@
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
@@ -182,9 +199,5 @@
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
@@ -200,9 +213,6 @@
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
apply_patch(auto_approved=true) exited 0 in 51ms:
Success. Updated the following files:
M tools/room/orchestrator.py
file update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Deciding build and test order**
codex
Fix 1 is patched. I’m running the required verification now: build first, then `tests/room` via pytest since this change touched Python orchestrator behavior.
exec
/bin/zsh -lc 'cmake --build ./build' in /Users/james/Repos/wibandwob-dosfile update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

 exited 2 in 2.33s:
[ 76%] Built target tvision
[ 91%] Built target test_pattern
[ 92%] Built target simple_tui
[ 93%] Built target frame_file_player
[ 94%] Built target ansi_viewer
[ 97%] Built target paint_tui
[ 98%] Built target tv_ascii_view
[ 98%] Built target ascii_dump
[ 98%] Linking CXX executable command_registry_test
Undefined symbols for architecture arm64:
  "api_chat_receive(TTestPatternApp&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&)", referenced from:
      exec_registry_command(TTestPatternApp&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>>> const&) in command_registry.cpp.o
ld: symbol(s) not found for architecture arm64
clang++: error: linker command failed with exit code 1 (use -v to see invocation)
make[2]: *** [app/command_registry_test] Error 1
make[1]: *** [app/CMakeFiles/command_registry_test.dir/all] Error 2
make: *** [all] Error 2

thinking
**Identifying long-running session polling**
file update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Noting pre-existing build failure**
exec
/bin/zsh -lc 'uv run --with pytest pytest tests/room/ -q' in /Users/james/Repos/wibandwob-dosfile update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

 succeeded in 5.02s:
........................................................................ [ 45%]
.......ss............................................................... [ 91%]
..............                                                           [100%]
156 passed, 2 skipped in 4.33s

thinking
**Committing scoped fix**
codex
Build hit the known pre-existing `command_registry_test` linker failure, but `tests/room` passed (`156 passed, 2 skipped`). I’m committing Fix 1 now and then moving to the C++ registry unification work.
exec
/bin/zsh -lc 'git add tools/room/orchestrator.py && git commit -m "fix(room): track and stop bridge sidecars in orchestrator"' in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
[feat/e008-multiplayer-partykit b18154b] fix(room): track and stop bridge sidecars in orchestrator
 1 file changed, 28 insertions(+), 18 deletions(-)
file update:
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Designing and planning match functions**
codex
I’m now editing the registry API to add a window matcher function pointer and then moving type-detection logic into `window_type_registry.cpp`, so `test_pattern_app.cpp` can consume it as the single lookup path.
file update
M /Users/james/Repos/wibandwob-dos/app/window_type_registry.h
@@ -10,2 +10,3 @@
 class TTestPatternApp;
+class TWindow;
 
@@ -14,2 +15,3 @@
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
@@ -18,2 +20,3 @@
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
apply_patch(auto_approved=true) exited 0 in 82ms:
Success. Updated the following files:
M app/window_type_registry.h
file update:
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Implementing window matchers and helpers**
file update
M /Users/james/Repos/wibandwob-dos/app/window_type_registry.cpp
@@ -5,2 +5,22 @@
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
@@ -153,2 +173,42 @@
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
@@ -157,24 +217,24 @@
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
apply_patch(auto_approved=true) exited 0 in 114ms:
Success. Updated the following files:
M app/window_type_registry.cpp
file update:
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Isolating window type registry patch**
file update
M /Users/james/Repos/wibandwob-dos/app/test_pattern_app.cpp
@@ -104,2 +104,3 @@
 #include "command_registry.h"
+#include "window_type_registry.h"
 
@@ -2396,42 +2397,8 @@
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
apply_patch(auto_approved=true) exited 0 in 159ms:
Success. Updated the following files:
M app/test_pattern_app.cpp
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..5af81228d71f552f17e9086328809eabfc571082
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..5af81228d71f552f17e9086328809eabfc571082
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Building after fix applied**
codex
Fix 2 is applied: matcher functions now live in the registry and `windowTypeName()` resolves through `all_window_type_specs()`. I’m building now to validate the C++ integration before committing.
exec
/bin/zsh -lc 'cmake --build ./build' in /Users/james/Repos/wibandwob-dosfile update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..5af81228d71f552f17e9086328809eabfc571082
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

 exited 2 in 8.09s:
[ 76%] Built target tvision
[ 76%] Building CXX object app/CMakeFiles/test_pattern.dir/test_pattern_app.cpp.o
[ 76%] Building CXX object app/CMakeFiles/test_pattern.dir/api_ipc.cpp.o
[ 77%] Building CXX object app/CMakeFiles/test_pattern.dir/window_type_registry.cpp.o
[ 77%] Linking CXX executable test_pattern
[ 91%] Built target test_pattern
[ 92%] Built target simple_tui
[ 93%] Built target frame_file_player
[ 94%] Built target ansi_viewer
[ 97%] Built target paint_tui
[ 98%] Built target tv_ascii_view
[ 98%] Built target ascii_dump
[ 98%] Linking CXX executable command_registry_test
Undefined symbols for architecture arm64:
  "api_chat_receive(TTestPatternApp&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&)", referenced from:
      exec_registry_command(TTestPatternApp&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>>> const&) in command_registry.cpp.o
ld: symbol(s) not found for architecture arm64
clang++: error: linker command failed with exit code 1 (use -v to see invocation)
make[2]: *** [app/command_registry_test] Error 1
make[1]: *** [app/CMakeFiles/command_registry_test.dir/all] Error 2
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..5af81228d71f552f17e9086328809eabfc571082
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Committing partial fixes with inspection plan**
exec
/bin/zsh -lc "git diff -- app/window_type_registry.h app/window_type_registry.cpp app/test_pattern_app.cpp | sed -n '1,260p'" in /Users/james/Repos/wibandwob-dos succeeded in 50ms:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa6..5af8122 100644
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@ class TWindow; TWindow* createAsciiGridDemoWindow(const TRect &bounds);
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@ bool api_open_workspace_path(TTestPatternApp& app, const std::string& path) {
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..5af81228d71f552f17e9086328809eabfc571082
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Committing fix update**
exec
/bin/zsh -lc 'git add app/window_type_registry.h app/window_type_registry.cpp app/test_pattern_app.cpp && git commit -m "fix(registry): unify window type detection through specs"' in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
[feat/e008-multiplayer-partykit a9c3964] fix(registry): unify window type detection through specs
 3 files changed, 91 insertions(+), 61 deletions(-)
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..5af81228d71f552f17e9086328809eabfc571082
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Fixing window registration signature**
codex
I’m applying Fix 3 now: adding an `emit_event` flag to `registerWindow` and switching `api_get_state` to silent ID assignment so reads no longer publish `state_changed`.
file update
M /Users/james/Repos/wibandwob-dos/app/test_pattern_app.cpp
@@ -642,3 +642,3 @@
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
@@ -652,3 +652,3 @@
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
@@ -2441,3 +2441,3 @@
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
apply_patch(auto_approved=true) exited 0 in 121ms:
Success. Updated the following files:
M app/test_pattern_app.cpp
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Scheduling build after fix**
exec
/bin/zsh -lc 'cmake --build ./build' in /Users/james/Repos/wibandwob-dosfile update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

 exited 2 in 5.35s:
[ 76%] Built target tvision
[ 76%] Building CXX object app/CMakeFiles/test_pattern.dir/test_pattern_app.cpp.o
[ 76%] Linking CXX executable test_pattern
[ 91%] Built target test_pattern
[ 92%] Built target simple_tui
[ 93%] Built target frame_file_player
[ 94%] Built target ansi_viewer
[ 97%] Built target paint_tui
[ 98%] Built target tv_ascii_view
[ 98%] Built target ascii_dump
[ 98%] Linking CXX executable command_registry_test
Undefined symbols for architecture arm64:
  "api_chat_receive(TTestPatternApp&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&)", referenced from:
      exec_registry_command(TTestPatternApp&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::less<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>>> const&) in command_registry.cpp.o
ld: symbol(s) not found for architecture arm64
clang++: error: linker command failed with exit code 1 (use -v to see invocation)
make[2]: *** [app/command_registry_test] Error 1
make[1]: *** [app/CMakeFiles/command_registry_test.dir/all] Error 2
make: *** [all] Error 2
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Recording minor fix commit**
exec
/bin/zsh -lc 'git add app/test_pattern_app.cpp && git commit -m "fix(api): suppress state_changed during api_get_state"' in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
[feat/e008-multiplayer-partykit 83645d7] fix(api): suppress state_changed during api_get_state
 1 file changed, 3 insertions(+), 3 deletions(-)
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Executing final codex command**
codex
All three fixes are committed. I’m running the requested final Codex verification command now and capturing output to `codex-arch-fixes-verification-20260218.log`.
exec
/bin/zsh -lc "codex exec -C /Users/james/Repos/wibandwob-dos 'Read CODEX-ARCH-REVIEW-20260218.md. Verify the 3 fixes above were correctly implemented (orchestrator bridge lifecycle, windowTypeName single source, registerWindow side-effect). Report any remaining issues.' 2>&1 | tee codex-arch-fixes-verification-20260218.log" in /Users/james/Repos/wibandwob-dosfile update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Planning completion polling**
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Polling reconnect status**
codex
The verification run is in progress but the Codex CLI stream is intermittently disconnecting and retrying; I’m keeping it running to capture the final result in the log file.
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

 succeeded in 24.26s:
2026-02-18T20:55:45.598079Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c67d3-e7fb-7423-879a-a3c6997f29d4
2026-02-18T20:55:45.618989Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-18T20:55:45.625111Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6171-ccc2-7702-9b67-9c22338e3137
2026-02-18T20:55:45.646211Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6248-4000-77b0-815a-4015ebbba891
2026-02-18T20:55:45.671035Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c7286-5118-7281-a418-ade288cdc3ff
Reconnecting... 1/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:55:48.975827Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 2/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:55:52.313983Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 3/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:55:55.993907Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 4/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:00.659983Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 5/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:06.765366Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-18T20:56:09.731017Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
ERROR: stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses)
ERROR: Failed to shutdown rollout recorder
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Planning final verification rerun**
codex
The first verification attempt completed with transport errors before any analysis output. I’m retrying the same `codex exec` command once to get a usable verification result in the log.
exec
/bin/zsh -lc "codex exec -C /Users/james/Repos/wibandwob-dos 'Read CODEX-ARCH-REVIEW-20260218.md. Verify the 3 fixes above were correctly implemented (orchestrator bridge lifecycle, windowTypeName single source, registerWindow side-effect). Report any remaining issues.' 2>&1 | tee codex-arch-fixes-verification-20260218.log" in /Users/james/Repos/wibandwob-dosfile update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Considering poll retries**
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

 succeeded in 24.05s:
2026-02-18T20:56:17.764727Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c67d3-e7fb-7423-879a-a3c6997f29d4
2026-02-18T20:56:17.785657Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-18T20:56:17.790587Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6171-ccc2-7702-9b67-9c22338e3137
2026-02-18T20:56:17.806176Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6248-4000-77b0-815a-4015ebbba891
2026-02-18T20:56:17.832162Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c7286-5118-7281-a418-ade288cdc3ff
Reconnecting... 1/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:20.833658Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 2/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:24.457015Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 3/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:28.194236Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 4/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:32.636191Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
Reconnecting... 5/5 (stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses))
2026-02-18T20:56:38.819552Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-18T20:56:41.709937Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
ERROR: stream disconnected before completion: error sending request for url (https://chatgpt.com/backend-api/codex/responses)
ERROR: Failed to shutdown rollout recorder

thinking
**Finalizing polling logic**
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Adding git status and log inspection**
codex
The retry failed the same way: Codex CLI could not keep a response stream long enough to return findings, though the log file was written with the failure details. I’m doing a final workspace check and then I’ll summarize all implemented changes and exact commit SHAs.
exec
/bin/zsh -lc 'tail -n 40 codex-arch-fixes-verification-20260218.log' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'git log --oneline -n 5' in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
WARNING: proceeding, even though we could not update PATH: Operation not permitted (os error 1)
OpenAI Codex v0.101.0 (research preview)
--------
workdir: /Users/james/Repos/wibandwob-dos
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c728a-144f-7a33-ad2f-e5a830d46291
--------
user
Read CODEX-ARCH-REVIEW-20260218.md. Verify the 3 fixes above were correctly implemented (orchestrator bridge lifecycle, windowTypeName single source, registerWindow side-effect). Report any remaining issues.
mcp startup: no servers
2026-02-18T20:56:17.764727Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c67d3-e7fb-7423-879a-a3c6997f29d4
2026-02-18T20:56:17.785657Z ERROR codex_core::codex: failed to record rollout items: failed to queue rollout items: channel closed
2026-02-18T20:56:17.790587Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6171-ccc2-7702-9b67-9c22338e3137
2026-02-18T20:56:17.806176Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6248-4000-77b0-815a-4015ebbba891
2026-02-18T20:56:17.832162Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c7286-5118-7281-a418-ade288cdc3ff
exec
/bin/zsh -lc 'git status --short' in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
83645d7 fix(api): suppress state_changed during api_get_state
a9c3964 fix(registry): unify window type detection through specs
b18154b fix(room): track and stop bridge sidecars in orchestrator
f45be44 docs(arch): pre-P0 architecture review log (predicted WindowTypeRegistry + event push)
8c27b2d docs(arch): Codex architecture review — 10 findings, action items
 succeeded in 52ms:
?? codex-arch-fixes-20260218.log
?? codex-arch-fixes-verification-20260218.log
?? codex-review-round5-20260218-202312.log
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Verifying log file creation and untracked logs**
exec
/bin/zsh -lc 'rg -n "bridge_procs|DEVNULL|_terminate_process|Stopping" tools/room/orchestrator.py' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'rg -n "WinMatchFn|matches" app/window_type_registry.h app/window_type_registry.cpp' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "rg -n \"windowTypeName\\(|all_window_type_specs\\(|registerWindow\\(TWindow\\* w, bool emit_event|registerWindow\\(w, false\\)\" app/test_pattern_app.cpp" in /Users/james/Repos/wibandwob-dos succeeded in 53ms:
app/window_type_registry.h:16:using WinMatchFn = bool (*)(TWindow*);
app/window_type_registry.h:21:    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 succeeded in 53ms:
39:    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
117:            stdout=subprocess.DEVNULL,
118:            stderr=subprocess.DEVNULL,
144:            room.bridge_procs.append(bridge_proc)
150:    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
200:        for bridge_proc in room.bridge_procs:
201:            self._terminate_process(bridge_proc, f"{room_id} bridge")
202:        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
214:        print(f"[orch] Stopping {room_id}")
215:        for bridge_proc in room.bridge_procs:
216:            self._terminate_process(bridge_proc, f"{room_id} bridge")
217:        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 succeeded in 52ms:
643:    std::string registerWindow(TWindow* w, bool emit_event = true) {
2397:static const char* windowTypeName(TWindow* w) {
2398:    const auto& specs = all_window_type_specs();
2442:        std::string id = app.registerWindow(w, false);
2445:             << ",\"type\":\"" << windowTypeName(w) << "\""
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Planning line number extraction**
exec
/bin/zsh -lc "rg -n \"match_test_pattern|match_gradient|k_specs\\[\\]|match_wibwob|match_scramble|has_child_view\" app/window_type_registry.cpp" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
175:static bool has_child_view(TWindow* w) {
187:static bool match_test_pattern(TWindow*) {
193:static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
194:static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
198:static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
199:static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
200:static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
201:static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
202:static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
203:static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
204:static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
205:static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
206:static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
207:static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
208:static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
209:static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
210:static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
211:static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
212:static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
217:static const WindowTypeSpec k_specs[] = {
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):


thinking
**Summarizing final build and test outcomes**
codex
Implemented all three fixes in order, with per-fix verification and commits.

1. **Fix 1: Orchestrator bridge lifecycle leak**  
Changes in `tools/room/orchestrator.py`:
- Track bridge processes in `RoomProcess.bridge_procs` (`tools/room/orchestrator.py:39`)
- Set `ttyd` I/O to `DEVNULL` (`tools/room/orchestrator.py:117`, `tools/room/orchestrator.py:118`)
- Store bridge `Popen` handle on spawn (`tools/room/orchestrator.py:144`)
- Added unified terminate/wait helper (`tools/room/orchestrator.py:150`)
- Stop bridge + ttyd in `restart_room` and `stop_room` (`tools/room/orchestrator.py:200`, `tools/room/orchestrator.py:214`)

Verification:
- `cmake --build ./build` (fails only on pre-existing `command_registry_test` linker issue)
- `uv run --with pytest pytest tests/room/ -q` -> `156 passed, 2 skipped`

Commit:
- `b18154b` `fix(room): track and stop bridge sidecars in orchestrator`

2. **Fix 2: `windowTypeName` ↔ registry desync**  
Changes:
- Added matcher function pointer in spec: `WinMatchFn` + `matches` field (`app/window_type_registry.h:16`, `app/window_type_registry.h:21`)
- Implemented match functions in registry and wired all `k_specs` entries (`app/window_type_registry.cpp:175`, `app/window_type_registry.cpp:217`)
- Replaced `windowTypeName()` custom chain with registry scan via `all_window_type_specs()` (`app/test_pattern_app.cpp:2397`)

Verification:
- `cmake --build ./build` (same pre-existing `command_registry_test` linker failure; `test_pattern` builds)

Commit:
- `a9c3964` `fix(registry): unify window type detection through specs`

3. **Fix 3: `registerWindow` side-effect during reads**  
Changes in `app/test_pattern_app.cpp`:
- `registerWindow(TWindow* w, bool emit_event = true)` (`app/test_pattern_app.cpp:643`)
- Event publish now guarded by `emit_event`
- `api_get_state` uses silent registration: `registerWindow(w, false)` (`app/test_pattern_app.cpp:2442`)

Verification:
- `cmake --build ./build` (same pre-existing linker issue)

Commit:
- `83645d7` `fix(api): suppress state_changed during api_get_state`

4. **Requested final Codex verification command**
Executed exactly as requested and wrote `codex-arch-fixes-verification-20260218.log`, but Codex CLI failed twice due stream disconnect/reconnect exhaustion (no analysis payload returned). Log contains the transport errors.

Notes:
- Workspace now has untracked logs including `codex-arch-fixes-verification-20260218.log`.
file update:
diff --git a/app/test_pattern_app.cpp b/app/test_pattern_app.cpp
index 3ee4fa67a478a2b1a67b8e9927d676b2f5bbd6d9..47fb9ec1b8e92c351d501a656d94ce9f0faa6210
--- a/app/test_pattern_app.cpp
+++ b/app/test_pattern_app.cpp
@@ -102,6 +102,7 @@
 // Local API IPC bridge (Unix domain socket)
 #include "api_ipc.h"
 #include "command_registry.h"
+#include "window_type_registry.h"
 
 // Find first existing primer directory across module paths.
 // Checks modules-private/*/primers/ then modules/*/primers/ then legacy app/primers/.
@@ -639,7 +640,7 @@
     std::map<TWindow*, std::string> winToId;
     std::map<std::string, TWindow*> idToWin;
     
-    std::string registerWindow(TWindow* w) {
+    std::string registerWindow(TWindow* w, bool emit_event = true) {
         if (!w) return std::string();
         auto it = winToId.find(w);
         if (it != winToId.end()) return it->second;
@@ -649,7 +650,7 @@
         winToId[w] = id;
         idToWin[id] = w;
         // Notify event subscribers that state has changed.
-        if (ipcServer) {
+        if (emit_event && ipcServer) {
             std::string payload = std::string("{\"id\":\"") + id + "\"}";
             ipcServer->publish_event("state_changed", payload);
         }
@@ -2394,46 +2395,12 @@
 void api_screenshot(TTestPatternApp& app) { app.takeScreenshot(false); }
 
 static const char* windowTypeName(TWindow* w) {
-    if (!w) return "test_pattern";
-
-    // Directly-typed windows whose classes are visible in this TU.
-    if (dynamic_cast<TTestPatternWindow*>(w))    return "test_pattern";
-    if (dynamic_cast<TGradientWindow*>(w))        return "gradient";
-    if (dynamic_cast<TBrowserWindow*>(w))         return "browser";
-    if (dynamic_cast<TTextEditorWindow*>(w))      return "text_editor";
-    if (dynamic_cast<TTransparentTextWindow*>(w)) return "text_view";
-    if (dynamic_cast<TFrameAnimationWindow*>(w))  return "frame_player";
-    if (dynamic_cast<TWibWobWindow*>(w))          return "wibwob";
-    if (dynamic_cast<TScrambleWindow*>(w))        return "scramble";
-
-    // Generative/animated window wrapper classes are local to their .cpp files
-    // and cannot be dynamic_cast from here. Identify them by their hosted
-    // child view type instead.
-#define HAS_CHILD_VIEW(ViewType) \
-    ([&]() -> bool { \
-        TView *_s = w->first(); \
-        if (!_s) return false; \
-        TView *_v = _s; \
-        do { if (dynamic_cast<ViewType*>(_v)) return true; _v = _v->next; } while (_v != _s); \
-        return false; \
-    }())
-
-    if (HAS_CHILD_VIEW(TGenerativeVerseView))         return "verse";
-    if (HAS_CHILD_VIEW(TGenerativeMyceliumView))      return "mycelium";
-    if (HAS_CHILD_VIEW(TGenerativeOrbitView))         return "orbit";
-    if (HAS_CHILD_VIEW(TGenerativeTorusView))         return "torus";
-    if (HAS_CHILD_VIEW(TGenerativeCubeView))          return "cube";
-    if (HAS_CHILD_VIEW(TGameOfLifeView))              return "life";
-    if (HAS_CHILD_VIEW(TAnimatedBlocksView))          return "blocks";
-    if (HAS_CHILD_VIEW(TAnimatedScoreView))           return "score";
-    if (HAS_CHILD_VIEW(TAnimatedAsciiView))           return "ascii";
-    if (HAS_CHILD_VIEW(TAnimatedHGradientView))       return "animated_gradient";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterCamView))    return "monster_cam";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterVerseView))  return "monster_verse";
-    if (HAS_CHILD_VIEW(TGenerativeMonsterPortalView)) return "monster_portal";
-
-#undef HAS_CHILD_VIEW
-    return "test_pattern";
+    const auto& specs = all_window_type_specs();
+    for (const auto& spec : specs) {
+        if (spec.matches && spec.matches(w)) return spec.type;
+    }
+    // Fallback to first registry entry (canonical default type slug).
+    return specs.empty() ? "test_pattern" : specs.front().type;
 }
 
 std::string api_get_state(TTestPatternApp& app) {
@@ -2472,7 +2439,7 @@
 
     bool first = true;
     for (TWindow* w : activeWins) {
-        std::string id = app.registerWindow(w);
+        std::string id = app.registerWindow(w, false);
         if (!first) json << ",";
         json << "{\"id\":\"" << id << "\""
              << ",\"type\":\"" << windowTypeName(w) << "\""
diff --git a/app/window_type_registry.cpp b/app/window_type_registry.cpp
index f52a16406d5f30cfb2bfbe21c637032b438a4629..b41306b428bfbc597c99be465b60981ec87261ec
--- a/app/window_type_registry.cpp
+++ b/app/window_type_registry.cpp
@@ -3,6 +3,26 @@
 // a new entry in the k_specs table below.
 
 #include "window_type_registry.h"
+#include "gradient.h"
+#include "frame_file_player_view.h"
+#include "transparent_text_view.h"
+#include "text_editor_view.h"
+#include "browser_view.h"
+#include "generative_verse_view.h"
+#include "generative_mycelium_view.h"
+#include "generative_orbit_view.h"
+#include "generative_torus_view.h"
+#include "generative_cube_view.h"
+#include "game_of_life_view.h"
+#include "animated_blocks_view.h"
+#include "animated_score_view.h"
+#include "animated_ascii_view.h"
+#include "animated_gradient_view.h"
+#include "generative_monster_cam_view.h"
+#include "generative_monster_verse_view.h"
+#include "generative_monster_portal_view.h"
+#include "wibwob_view.h"
+#include "scramble_view.h"
 
 // tvision for TRect
 #define Uses_TRect
@@ -151,32 +171,72 @@
     TRect r; api_spawn_monster_portal(app, opt_bounds(kv, r)); return nullptr;
 }
 
+template <typename ViewType>
+static bool has_child_view(TWindow* w) {
+    if (!w) return false;
+    TView* start = w->first();
+    if (!start) return false;
+    TView* v = start;
+    do {
+        if (dynamic_cast<ViewType*>(v)) return true;
+        v = v->next;
+    } while (v != start);
+    return false;
+}
+
+static bool match_test_pattern(TWindow*) {
+    // TTestPatternWindow/TTestPatternView are local to test_pattern_app.cpp.
+    // The app falls back to this registry's first entry when no matcher hits.
+    return false;
+}
+
+static bool match_gradient(TWindow* w) { return has_child_view<TGradientView>(w); }
+static bool match_frame_player(TWindow* w) { return has_child_view<FrameFilePlayerView>(w) || has_child_view<TTextFileView>(w); }
+static bool match_text_view(TWindow* w) { return dynamic_cast<TTransparentTextWindow*>(w) != nullptr; }
+static bool match_text_editor(TWindow* w) { return dynamic_cast<TTextEditorWindow*>(w) != nullptr; }
+static bool match_browser(TWindow* w) { return dynamic_cast<TBrowserWindow*>(w) != nullptr; }
+static bool match_verse(TWindow* w) { return has_child_view<TGenerativeVerseView>(w); }
+static bool match_mycelium(TWindow* w) { return has_child_view<TGenerativeMyceliumView>(w); }
+static bool match_orbit(TWindow* w) { return has_child_view<TGenerativeOrbitView>(w); }
+static bool match_torus(TWindow* w) { return has_child_view<TGenerativeTorusView>(w); }
+static bool match_cube(TWindow* w) { return has_child_view<TGenerativeCubeView>(w); }
+static bool match_life(TWindow* w) { return has_child_view<TGameOfLifeView>(w); }
+static bool match_blocks(TWindow* w) { return has_child_view<TAnimatedBlocksView>(w); }
+static bool match_score(TWindow* w) { return has_child_view<TAnimatedScoreView>(w); }
+static bool match_ascii(TWindow* w) { return has_child_view<TAnimatedAsciiView>(w); }
+static bool match_animated_gradient(TWindow* w) { return has_child_view<TAnimatedHGradientView>(w); }
+static bool match_monster_cam(TWindow* w) { return has_child_view<TGenerativeMonsterCamView>(w); }
+static bool match_monster_verse(TWindow* w) { return has_child_view<TGenerativeMonsterVerseView>(w); }
+static bool match_monster_portal(TWindow* w) { return has_child_view<TGenerativeMonsterPortalView>(w); }
+static bool match_wibwob(TWindow* w) { return dynamic_cast<TWibWobWindow*>(w) != nullptr; }
+static bool match_scramble(TWindow* w) { return dynamic_cast<TScrambleWindow*>(w) != nullptr; }
+
 // ── Registry table ────────────────────────────────────────────────────────────
 // Add new window types here — nowhere else.
 
 static const WindowTypeSpec k_specs[] = {
-    { "test_pattern",      spawn_test             },
-    { "gradient",          spawn_gradient         },
-    { "frame_player",      spawn_frame_player     },
-    { "text_view",         spawn_text_view        },
-    { "text_editor",       spawn_text_editor      },
-    { "browser",           spawn_browser          },
-    { "verse",             spawn_verse            },
-    { "mycelium",          spawn_mycelium         },
-    { "orbit",             spawn_orbit            },
-    { "torus",             spawn_torus            },
-    { "cube",              spawn_cube             },
-    { "life",              spawn_life             },
-    { "blocks",            spawn_blocks           },
-    { "score",             spawn_score            },
-    { "ascii",             spawn_ascii            },
-    { "animated_gradient", spawn_animated_gradient},
-    { "monster_cam",       spawn_monster_cam      },
-    { "monster_verse",     spawn_monster_verse    },
-    { "monster_portal",    spawn_monster_portal   },
+    { "test_pattern",      spawn_test,              match_test_pattern      },
+    { "gradient",          spawn_gradient,          match_gradient          },
+    { "frame_player",      spawn_frame_player,      match_frame_player      },
+    { "text_view",         spawn_text_view,         match_text_view         },
+    { "text_editor",       spawn_text_editor,       match_text_editor       },
+    { "browser",           spawn_browser,           match_browser           },
+    { "verse",             spawn_verse,             match_verse             },
+    { "mycelium",          spawn_mycelium,          match_mycelium          },
+    { "orbit",             spawn_orbit,             match_orbit             },
+    { "torus",             spawn_torus,             match_torus             },
+    { "cube",              spawn_cube,              match_cube              },
+    { "life",              spawn_life,              match_life              },
+    { "blocks",            spawn_blocks,            match_blocks            },
+    { "score",             spawn_score,             match_score             },
+    { "ascii",             spawn_ascii,             match_ascii             },
+    { "animated_gradient", spawn_animated_gradient, match_animated_gradient },
+    { "monster_cam",       spawn_monster_cam,       match_monster_cam       },
+    { "monster_verse",     spawn_monster_verse,     match_monster_verse     },
+    { "monster_portal",    spawn_monster_portal,    match_monster_portal    },
     // Internal-only types — recognised but not spawnable via IPC
-    { "wibwob",            nullptr                },
-    { "scramble",          nullptr                },
+    { "wibwob",            nullptr,                match_wibwob             },
+    { "scramble",          nullptr,                match_scramble           },
 };
 
 // ── Lookup implementations ────────────────────────────────────────────────────
diff --git a/app/window_type_registry.h b/app/window_type_registry.h
index 0e036d8e583b5f37b137146661a89d0940404814..897042d2574997e96b3916f70042d9e37092e28a
--- a/app/window_type_registry.h
+++ b/app/window_type_registry.h
@@ -8,14 +8,17 @@
 #include <map>
 
 class TTestPatternApp;
+class TWindow;
 
 // Spawn callback: return nullptr on success, a static error string on failure.
 using WinSpawnFn = const char* (*)(TTestPatternApp&,
                                    const std::map<std::string, std::string>&);
+using WinMatchFn = bool (*)(TWindow*);
 
 struct WindowTypeSpec {
     const char* type;    // canonical slug, e.g. "verse", "gradient"
     WinSpawnFn  spawn;   // nullptr = recognised but not creatable via IPC
+    WinMatchFn  matches; // identifies whether a TWindow instance is this type
 };
 
 // Finds the spec for the given type slug (exact match). Returns nullptr if not found.
diff --git a/tools/room/orchestrator.py b/tools/room/orchestrator.py
index 8eeb4a2769753ab9144cc2965f16d3ee81a6516b..633a082138e3364bda6436d5187e14fbb2d35191
--- a/tools/room/orchestrator.py
+++ b/tools/room/orchestrator.py
@@ -36,6 +36,7 @@
 
     config: RoomConfig
     ttyd_proc: Optional[subprocess.Popen] = None
+    bridge_procs: list[subprocess.Popen] = field(default_factory=list)
     auth_secret: str = ""
     start_time: float = 0.0
     restart_count: int = 0
@@ -113,8 +114,8 @@
         proc = subprocess.Popen(
             ttyd_cmd,
             env=env,
-            stdout=subprocess.PIPE,
-            stderr=subprocess.PIPE,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
         )
 
         room = RoomProcess(
@@ -132,16 +133,32 @@
                 "uv", "run",
                 str(self.project_root / "tools" / "room" / "partykit_bridge.py"),
             ]
-            subprocess.Popen(
+            bridge_stdout = open(bridge_log, "a")
+            bridge_proc = subprocess.Popen(
                 bridge_cmd,
                 env=env,
-                stdout=open(bridge_log, "a"),
+                stdout=bridge_stdout,
                 stderr=subprocess.STDOUT,
             )
+            bridge_stdout.close()
+            room.bridge_procs.append(bridge_proc)
             print(f"[orch] Spawned PartyKit bridge for {config.room_id} -> {config.partykit_server}/party/{config.partykit_room}")
 
         return room
 
+    @staticmethod
+    def _terminate_process(proc: Optional[subprocess.Popen], name: str):
+        """Terminate a subprocess, escalating to kill after timeout."""
+        if proc is None or proc.poll() is not None:
+            return
+        try:
+            proc.terminate()
+            proc.wait(timeout=5)
+        except subprocess.TimeoutExpired:
+            print(f"[orch] {name} did not exit after SIGTERM, sending SIGKILL")
+            proc.kill()
+            proc.wait(timeout=5)
+
     def probe_socket(self, sock_path: str) -> bool:
         """Check if a WibWob IPC socket is responding."""
         try:
@@ -180,13 +197,9 @@
         room = self.rooms[room_id]
         print(f"[orch] Restarting {room_id} (restart #{room.restart_count + 1})")
 
-        # Kill existing process if still running
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
 
         # Respawn
         new_room = self.spawn_room(room.config)
@@ -198,13 +211,10 @@
         if room_id not in self.rooms:
             return
         room = self.rooms[room_id]
-        if room.ttyd_proc and room.ttyd_proc.poll() is None:
-            print(f"[orch] Stopping {room_id}")
-            room.ttyd_proc.terminate()
-            try:
-                room.ttyd_proc.wait(timeout=5)
-            except subprocess.TimeoutExpired:
-                room.ttyd_proc.kill()
+        print(f"[orch] Stopping {room_id}")
+        for bridge_proc in room.bridge_procs:
+            self._terminate_process(bridge_proc, f"{room_id} bridge")
+        self._terminate_process(room.ttyd_proc, f"{room_id} ttyd")
         del self.rooms[room_id]
 
     def stop_all(self):

tokens used
95,728
Implemented all three fixes in order, with per-fix verification and commits.

1. **Fix 1: Orchestrator bridge lifecycle leak**  
Changes in `tools/room/orchestrator.py`:
- Track bridge processes in `RoomProcess.bridge_procs` (`tools/room/orchestrator.py:39`)
- Set `ttyd` I/O to `DEVNULL` (`tools/room/orchestrator.py:117`, `tools/room/orchestrator.py:118`)
- Store bridge `Popen` handle on spawn (`tools/room/orchestrator.py:144`)
- Added unified terminate/wait helper (`tools/room/orchestrator.py:150`)
- Stop bridge + ttyd in `restart_room` and `stop_room` (`tools/room/orchestrator.py:200`, `tools/room/orchestrator.py:214`)

Verification:
- `cmake --build ./build` (fails only on pre-existing `command_registry_test` linker issue)
- `uv run --with pytest pytest tests/room/ -q` -> `156 passed, 2 skipped`

Commit:
- `b18154b` `fix(room): track and stop bridge sidecars in orchestrator`

2. **Fix 2: `windowTypeName` ↔ registry desync**  
Changes:
- Added matcher function pointer in spec: `WinMatchFn` + `matches` field (`app/window_type_registry.h:16`, `app/window_type_registry.h:21`)
- Implemented match functions in registry and wired all `k_specs` entries (`app/window_type_registry.cpp:175`, `app/window_type_registry.cpp:217`)
- Replaced `windowTypeName()` custom chain with registry scan via `all_window_type_specs()` (`app/test_pattern_app.cpp:2397`)

Verification:
- `cmake --build ./build` (same pre-existing `command_registry_test` linker failure; `test_pattern` builds)

Commit:
- `a9c3964` `fix(registry): unify window type detection through specs`

3. **Fix 3: `registerWindow` side-effect during reads**  
Changes in `app/test_pattern_app.cpp`:
- `registerWindow(TWindow* w, bool emit_event = true)` (`app/test_pattern_app.cpp:643`)
- Event publish now guarded by `emit_event`
- `api_get_state` uses silent registration: `registerWindow(w, false)` (`app/test_pattern_app.cpp:2442`)

Verification:
- `cmake --build ./build` (same pre-existing linker issue)

Commit:
- `83645d7` `fix(api): suppress state_changed during api_get_state`

4. **Requested final Codex verification command**
Executed exactly as requested and wrote `codex-arch-fixes-verification-20260218.log`, but Codex CLI failed twice due stream disconnect/reconnect exhaustion (no analysis payload returned). Log contains the transport errors.

Notes:
- Workspace now has untracked logs including `codex-arch-fixes-verification-20260218.log`.
