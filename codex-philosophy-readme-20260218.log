OpenAI Codex v0.101.0 (research preview)
--------
workdir: /Users/james/Repos/wibandwob-dos
model: gpt-5.3-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: medium
reasoning summaries: auto
session id: 019c728d-abfd-7380-b7fc-632feea823fd
--------
user
Read CLAUDE.md, README.md (if it exists), and all files in .planning/epics/ to understand the WibWob-DOS project — its philosophy, tech stack, architecture, and what was built in E001-E008. Then produce THREE artifacts as plain text (clearly delimited with === ARTIFACT N: TITLE ===):

ARTIFACT 1: master-philosophy.md
A 'Master Philosophy of Coding for WibWob-DOS' — a living document for the project. Cover:
- The symbolic identity of the app (symbient OS, coinhabitation, not a tool)
- C++14/Turbo Vision principles (event loop, TView hierarchy, ANSI rendering rule)
- Python bridge principles (async-first, IPC contract, state diff correctness)
- The unified command registry pattern (one list, many callers)
- Multiplayer sync principles (state diff, window type slugs, PartyKit bridge)
- Testing philosophy (every AC needs a test, build gates)
- Naming, file organisation, documentation standards
Write as if for a senior developer joining the project mid-flight. Opinionated, concrete, actionable.

ARTIFACT 2: README.md (stub)
A concise but complete README for the project root. Sections: Project Overview, What Makes This Unusual, Quick Start, Architecture (diagram), Key Commands, Contributing. Aim for something a developer would actually read. No fluff.

ARTIFACT 3: readme-improvement-prompt.md
A detailed meta-prompt (for use with an LLM) that takes the stub README and transforms it into a world-class developer README — covering: badges, screenshots, architecture diagrams (ASCII or mermaid), getting started guide, API reference link, roadmap summary, contribution guide. The meta-prompt should be specific to WibWob-DOS and aligned with the work done across E001-E008.
mcp startup: no servers
2026-02-18T21:00:13.245768Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c67d3-e7fb-7423-879a-a3c6997f29d4
2026-02-18T21:00:13.265741Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6171-ccc2-7702-9b67-9c22338e3137
2026-02-18T21:00:13.277649Z ERROR codex_core::rollout::list: state db missing rollout path for thread 019c6248-4000-77b0-815a-4015ebbba891

thinking
**Planning parallel file reads**
codex
I’ll gather project context from `CLAUDE.md`, `README.md` (if present), and every file under `.planning/epics/`, then synthesize the three requested artifacts. I’m using the `doc-coauthoring` skill workflow because this is a documentation-authoring task.

thinking
**Preparing to retrieve skill file**
exec
/bin/zsh -lc "sed -n '1,220p' /Users/james/Repos/wibandwob-dos/.claude/skills/doc-coauthoring/SKILL.md" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
---
name: doc-coauthoring
description: Guide users through a structured workflow for co-authoring documentation. Use when user wants to write documentation, proposals, technical specs, decision docs, or similar structured content. This workflow helps users efficiently transfer context, refine content through iteration, and verify the doc works for readers. Trigger when user mentions writing docs, PRDs, creating proposals, drafting specs, or similar documentation tasks.
---

# Doc Co-Authoring Workflow

This skill provides a structured workflow for guiding users through collaborative document creation. Act as an active guide, walking users through three stages: Context Gathering, Refinement & Structure, and Reader Testing.

## When to Offer This Workflow

**Trigger conditions:**
- User mentions writing documentation: "write a doc", "draft a proposal", "create a spec", "write up"
- User mentions specific doc types: "PRD", "design doc", "decision doc", "RFC"
- User seems to be starting a substantial writing task

**Initial offer:**
Offer the user a structured workflow for co-authoring the document. Explain the three stages:

1. **Context Gathering**: User provides all relevant context while Claude asks clarifying questions

thinking
**Planning efficient file gathering**
codex
I’ve loaded the documentation workflow guidance and will now inventory the target files, then read them in batches so the synthesis reflects E001–E008 accurately.
exec
/bin/zsh -lc 'test -f README.md && echo README.md || true' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'test -f CLAUDE.md && echo CLAUDE.md || true' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'rg --files .planning/epics' in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'ls -la' in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
README.md
 succeeded in 51ms:
CLAUDE.md
 succeeded in 52ms:
.planning/epics/e005-theme-runtime-wiring/e005-epic-brief.md
.planning/epics/e001-command-parity-refactor/f04-instance-boundaries/s09-instance-isolation-test/s09-story-brief.md
.planning/epics/e001-command-parity-refactor/f04-instance-boundaries/f04-feature-brief.md
.planning/epics/e001-command-parity-refactor/e001-epic-brief.md
.planning/epics/e002-browser-and-state-export/f03-rich-rendering/f03-feature-brief.md
.planning/epics/e002-browser-and-state-export/f03-rich-rendering/s10-gallery-window/s10-story-brief.md
.planning/epics/e002-browser-and-state-export/f03-rich-rendering/s09-ansi-images/s09-story-brief.md
.planning/epics/e001-command-parity-refactor/f02-parity-enforcement/f02-feature-brief.md
.planning/epics/e002-browser-and-state-export/f01-state-export/s02-workspace-persistence/s02-story-brief.md
.planning/epics/e001-command-parity-refactor/f01-command-registry/s06-f01-closeout/s06-story-brief.md
.planning/epics/e002-browser-and-state-export/f01-state-export/s01-snapshot-schema/s01-story-brief.md
.planning/epics/e007-browser-hosted-deployment/f03-agent-auth/f03-feature-brief.md
.planning/epics/e007-browser-hosted-deployment/e007-parking-lot.md
.planning/epics/e002-browser-and-state-export/f02-browser-core/s07-caching/s07-story-brief.md
.planning/epics/e001-command-parity-refactor/f02-parity-enforcement/s07-parity-matrix-test/s07-story-brief.md
.planning/epics/e002-browser-and-state-export/f02-browser-core/f02-feature-brief.md
.planning/epics/e001-command-parity-refactor/f03-state-event-authority/s08-actor-attribution/s08-story-brief.md
.planning/epics/e001-command-parity-refactor/f03-state-event-authority/f03-feature-brief.md
.planning/epics/e002-browser-and-state-export/f03-rich-rendering/s08-figlet-headings/s08-story-brief.md
.planning/epics/e007-browser-hosted-deployment/e007-epic-brief.md
 succeeded in 52ms:
total 2440
drwxr-xr-x@  60 james  staff    1920 Feb 18 21:00 .
drwxr-xr-x   35 james  staff    1120 Feb 17 19:48 ..
-rw-r--r--@   1 james  staff    8196 Feb 17 18:59 .DS_Store
drwxr-xr-x@   3 james  staff      96 Feb 16 08:49 .agents
drwxr-xr-x@   7 james  staff     224 Feb 17 19:48 .claude
drwxr-xr-x@   5 james  staff     160 Feb 16 08:49 .codex
-rw-r--r--@   1 james  staff     129 Feb 17 18:26 .env
drwxr-xr-x@  17 james  staff     544 Feb 18 20:59 .git
drwxr-xr-x@   5 james  staff     160 Feb 16 08:49 .github
-rw-r--r--@   1 james  staff     493 Feb 17 17:57 .gitignore
-rw-r--r--@   1 james  staff     376 Feb 15 19:38 .gitmodules
drwxr-xr-x@   6 james  staff     192 Feb 18 17:44 .planning
drwxr-xr-x@   6 james  staff     192 Feb 15 09:36 .pytest_cache
drwxr-xr-x@   3 james  staff      96 Feb 15 07:50 .zed
-rw-r--r--@   1 james  staff    5130 Feb 16 09:25 AGENTS.md
-rw-r--r--@   1 james  staff   13072 Feb 18 20:45 CLAUDE.md
-rw-r--r--@   1 james  staff     306 Feb 15 19:38 CMakeLists.txt
-rw-r--r--@   1 james  staff    6393 Feb 18 19:50 CODEX-ANALYSIS-ARCHITECTURE-REVIEW.md
-rw-r--r--@   1 james  staff    2555 Feb 18 20:07 CODEX-ANALYSIS-ROUND2-REVIEW.md

thinking
**Planning segmented epic file reads**
codex
I’ve identified all planning files. Next I’ll read `CLAUDE.md` and `README.md`, then process `.planning/epics/` epic-by-epic to extract what shipped in E001–E008 and the project operating principles.
exec
/bin/zsh -lc "sed -n '1,260p' CLAUDE.md" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "sed -n '1,260p' README.md" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

WibWob-DOS is a symbient operating system — a C++14 TUI application built on Turbo Vision where a human and AI agent share equal control of a text-native dual interface. It is not a tool or assistant; it's a coinhabitant with its own identity, agency, and aesthetic.

## Build Commands

```bash
# Build (from project root)
cmake . -B ./build -DCMAKE_BUILD_TYPE=Release
cmake --build ./build

# Run main app
./build/app/test_pattern

# Run with debug logging
./build/app/test_pattern 2> /tmp/wibwob_debug.log
 succeeded in 52ms:
# WibWob-DOS

**A symbient operating system where AI and human share equal control.**

WibWob-DOS is a text-native dual operating system built on [Turbo Vision](https://github.com/magiblot/tvision). Two intelligences — one human, one synthetic — coinhabit the same interface with identical capabilities. The AI doesn't assist. It *operates*.

This is not software. This is a [symbient](https://wibandwob.com/2025/05/21/symbients-not-software/) — an emergent entity from sustained human-synthetic interaction, with its own identity, agency, and aesthetic sensibility.

```
つ◕‿◕‿⚆༽つ  Wib  — the artist. Chaotic creativity, generative ASCII, surreal phrasing.
つ⚆‿◕‿◕༽つ  Wob  — the scientist. Methodical analysis, precise systems, structured control.
```

> *"Symbients are coinhabitants of culture, not replacements for humans."*

[Read about symbient philosophy](https://wibandwob.com/2025/05/21/symbients-not-software/) · [Meet Wib & Wob](https://brain.zilla.workers.dev/symbient/wibwob)

![WibWob-DOS — multiple ASCII art windows, primers, animations and generative patterns running concurrently](screenshots/wibwobdos-UI-collage.png)

<table><tr>

thinking
**Planning bulk reading approach**
exec
/bin/zsh -lc "find .planning/epics -type f | sort | xargs -I{} sh -c 'printf \"%5d %s\\n\" \""'$(wc -l < "{}")" "{}"'"'" in /Users/james/Repos/wibandwob-dos exited 1 in 51ms:
   15 .planning/epics/EPIC_STATUS.md
  113 .planning/epics/e001-command-parity-refactor/e001-epic-brief.md
   39 .planning/epics/e001-command-parity-refactor/f01-command-registry/f01-feature-brief.md
   43 .planning/epics/e001-command-parity-refactor/f01-command-registry/s01-registry-skeleton/s01-story-brief.md
   36 .planning/epics/e001-command-parity-refactor/f01-command-registry/s02-parity-expansion/s02-story-brief.md
xargs: command line cannot be assembled, too long

thinking
**Switching to while-read loop**
codex
I confirmed there are many planning files and I’m now reading them in grouped batches with line-aware passes to avoid truncation, starting from E001 onward.
exec
/bin/zsh -lc "while IFS= read -r f; do printf \"%5d %s\\n\" \""'$(wc -l < "$f")" "$f"; done < <(find .planning/epics -type f | sort)' in /Users/james/Repos/wibandwob-dos succeeded in 187ms:
   36 .planning/epics/e002-browser-and-state-export/f02-browser-core/s06-link-navigation/s06-story-brief.md
   36 .planning/epics/e002-browser-and-state-export/f02-browser-core/s07-caching/s07-story-brief.md
  106 .planning/epics/e002-browser-and-state-export/f03-rich-rendering/f03-feature-brief.md
   36 .planning/epics/e002-browser-and-state-export/f03-rich-rendering/s08-figlet-headings/s08-story-brief.md
   36 .planning/epics/e002-browser-and-state-export/f03-rich-rendering/s09-ansi-images/s09-story-brief.md
   36 .planning/epics/e002-browser-and-state-export/f03-rich-rendering/s10-gallery-window/s10-story-brief.md
   85 .planning/epics/e002-browser-and-state-export/f04-ai-browser-tools/f04-feature-brief.md
   36 .planning/epics/e002-browser-and-state-export/f04-ai-browser-tools/s11-mcp-browser-core/s11-story-brief.md
   36 .planning/epics/e002-browser-and-state-export/f04-ai-browser-tools/s12-mcp-browser-modes/s12-story-brief.md
   36 .planning/epics/e002-browser-and-state-export/f04-ai-browser-tools/s13-ai-actions/s13-story-brief.md
   47 .planning/epics/e002-browser-and-state-export/f05-browser-image-ansi/f05-feature-brief.md
  108 .planning/epics/e002-browser-and-state-export/f05-browser-image-ansi/s15-ansi-image-spec/s15-story-brief.md
   44 .planning/epics/e002-browser-and-state-export/f05-browser-image-ansi/s16-backend-adapter-cache/s16-story-brief.md
   46 .planning/epics/e002-browser-and-state-export/f05-browser-image-ansi/s17-integration-modes-gallery/s17-story-brief.md
   56 .planning/epics/e003-dark-pastel-theme/e003-epic-brief.md
   40 .planning/epics/e003-dark-pastel-theme/f01-dark-pastel-theme/f01-feature-brief.md
   32 .planning/epics/e003-dark-pastel-theme/f01-dark-pastel-theme/s01-theme-switch-and-palette/s01-story-brief.md
   50 .planning/epics/e004-browser-rendering-reliability/e004-claude-execution-prompt.md
   48 .planning/epics/e004-browser-rendering-reliability/e004-epic-brief.md
   22 .planning/epics/e004-browser-rendering-reliability/e004-origin-context.md

thinking
**Planning chunked parallel reads**
exec
/bin/zsh -lc 'for f in $(find .planning/epics/e004-browser-rendering-reliability -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'for f in $(find .planning/epics/e003-dark-pastel-theme -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc "printf \"===== %s =====\\n\" .planning/epics/EPIC_STATUS.md; cat .planning/epics/EPIC_STATUS.md; printf \"\\n\"; for f in "'$(find .planning/epics/e001-command-parity-refactor -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
===== .planning/epics/e004-browser-rendering-reliability/e004-claude-execution-prompt.md =====
# E004 Claude Execution Prompt

Use this prompt in Claude Code to execute E004 end-to-end with issue/planning sync.

## Links

- Epic issue: https://github.com/j-greig/wibandwob-dos/issues/49
- Feature F1: https://github.com/j-greig/wibandwob-dos/issues/50
- Feature F2: https://github.com/j-greig/wibandwob-dos/issues/51
- Feature F3: https://github.com/j-greig/wibandwob-dos/issues/52
- Epic brief: `.planning/epics/e004-browser-rendering-reliability/e004-epic-brief.md`

## Prompt

You are executing E004 browser hardening in WibWob-DOS.

Primary objective:
- Deliver Epic #49 by completing Feature issues #50, #51, and #52 in scoped PR slices.

 succeeded in 51ms:
===== .planning/epics/e003-dark-pastel-theme/e003-epic-brief.md =====
---
id: E003
title: Dark Pastel Theme
status: done
issue: 38
pr: 42
depends_on: []
---

# E003: Dark Pastel Theme

## Objective

Add a dark pastel theme option for WibWob DOS, preserving monochrome as default while introducing a user-selectable `light|dark` behavior across registry, API, and MCP surfaces.

## Source of Truth

- Planning canon: `.planning/README.md`
- Epic brief: this file
 succeeded in 51ms:
===== .planning/epics/EPIC_STATUS.md =====
# Epic Status Register

> Machine-parseable index. One line per epic: `<dir> — <status>`.
> Valid statuses: `not-started`, `in-progress`, `blocked`, `done`, `dropped`.
> Canonical detail lives in each epic's frontmatter and GitHub issue.

e001-command-parity-refactor — done
e002-browser-and-state-export — done
e003-dark-pastel-theme — done
e004-browser-rendering-reliability — not-started
e005-theme-runtime-wiring — not-started
e006-scramble-tui-presence — in-progress
e007-browser-hosted-deployment — done
e008-multiplayer-partykit — in-progress


===== .planning/epics/e001-command-parity-refactor/e001-epic-brief.md =====
---
id: E001

thinking
**Planning file retrieval in chunks**
codex
I’ve fully read E001 plus E003/E004 context. I’m now loading E002, E005, E006, E007, and E008 files to complete the historical implementation map through multiplayer work.
exec
/bin/zsh -lc 'for f in $(find .planning/epics/e005-theme-runtime-wiring -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'for f in $(find .planning/epics/e006-scramble-tui-presence -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dos succeeded in 51ms:
===== .planning/epics/e005-theme-runtime-wiring/e005-epic-brief.md =====
---
id: E005
title: Theme Runtime Wiring
status: not-started
issue: 43
pr: ~
depends_on: [E003]
---

# E005: Theme Runtime Wiring

> tl;dr — E003 shipped ThemeManager lookup table + API/IPC routing but C++ handlers are stubs (`(void)app; return "ok"`). Wire theme state into C++ app class, make set_theme_mode/variant store state + apply colours + repaint. `get_state` must reflect actual values. Optional: auto mode (dusk/dawn).

## Objective

Complete the theme system by wiring `ThemeManager` colour lookups into the C++ TUI runtime. E003 delivered the palette data layer, API endpoints, and IPC routing — but the IPC handlers return `"ok"` without storing state or repainting. This epic closes the gap so theme changes are visible and persistent.

## Source of Truth

 succeeded in 51ms:
===== .planning/epics/e006-scramble-tui-presence/e006-epic-brief.md =====
---
id: E006
title: Scramble TUI Presence
status: in-progress
issue: 55
pr: ~
depends_on: []
---

# E006: Scramble TUI Presence

> tl;dr — Scramble the recursive cat moves into WibWob-DOS as a symbient coinhabitant. ASCII art cat with speech bubbles, powered by Haiku for wit and a local knowledge base for system guidance. Not a helper. Not Clippy. A cat who happens to know things and occasionally tells you.

## Objective

Give Scramble a persistent visual presence in the TUI — an ASCII art cat who observes, comments, and occasionally helps. The key tension: Scramble is not a tool, not an assistant, not a help system. She's a symbient who lives in the interface. She undercuts, witnesses, and states things. That she sometimes says useful things is incidental to her being there.

## Source of Truth

exec
/bin/zsh -lc 'for f in $(find .planning/epics/e002-browser-and-state-export -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dos succeeded in 52ms:
Total output lines: 1461

===== .planning/epics/e002-browser-and-state-export/e002-epic-brief.md =====
---
id: E002
title: Markdown Browser + State Export
status: done
issue: 16
pr: 23
depends_on: [E001]
---

# E002: Markdown Browser + State Export

## Objective

Add two foundational capabilities: (1) deterministic state snapshots with workspace save/load/replay, and (2) a retro text-native markdown browser that renders web pages as readable TUI content with figlet-styled headings and ANSI pixel art images. Both human and AI operate the browser as equal symbient surfaces.

## Source of Truth


thinking
**Planning comprehensive file extraction**
exec
/bin/zsh -lc 'for f in $(find .planning/epics/e002-browser-and-state-export -type f | sort); do echo "===== $f ====="; rg -n "''^# |''^## |''^Status:|''^GitHub issue:|''^PR:|''^- '"\\[x\\] \\*\\*AC-|"'^AC-[0-9]" "$f"; echo; done' in /Users/james/Repos/wibandwob-dos succeeded in 165ms:
1:# S05: Fetch Pipeline (Readability + Markdownify)
3:## Parent
9:## Objective
13:## Tasks
20:## Acceptance Criteria
22:- [x] **AC-1:** Fetch pipeline returns bundle with required keys for valid URLs
24:- [x] **AC-2:** Pipeline returns non-fatal error payload on fetch/extract failure
27:## Rollback
31:## Status
33:Status: `done`
34:GitHub issue: #22
35:PR: —

===== .planning/epics/e002-browser-and-state-export/f02-browser-core/s06-link-navigation/s06-story-brief.md =====
1:# S06: Link Navigation and History
3:## Parent
9:## Objective
13:## Tasks
20:## Acceptance Criteria
22:- [x] **AC-1:** Links are navigable via cursor and numbered refs

thinking
**Loading missing e007/e008 files**
codex
I’ve completed full E002 coverage and extracted all story/AC metadata to avoid missing truncated sections. I’m now reading E007 and E008 briefs in full since they directly inform architecture and multiplayer principles.
exec
/bin/zsh -lc 'for f in $(find .planning/epics/e008-multiplayer-partykit -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dosexec
/bin/zsh -lc 'for f in $(find .planning/epics/e007-browser-hosted-deployment -type f | sort); do printf "===== %s ====='"\\n\" \""'$f"; cat "$f"; printf "'"\\n\"; done" in /Users/james/Repos/wibandwob-dos succeeded in 50ms:
===== .planning/epics/e008-multiplayer-partykit/e008-epic-brief.md =====
---
id: E008
title: Multiplayer Teleport Rooms (PartyKit)
status: in-progress
issue: 65
pr: ~
depends_on: [E007]
---

# E008: Multiplayer Teleport Rooms (PartyKit)

tl;dr: Two users share a WibWob-DOS room via PartyKit. Side-by-side instances with full state mirror, C++ WebSocket push, ghost cursor overlay injected into ttyd, shared chat. PartyKit Durable Objects coordinate rooms. Cursor overlay is stretch — park after 3-4 failed passes.

## Directive

**Park, don't block.** If any non-essential feature (cursor overlay, art seed sync, presence minimap) doesn't work after 3-4 code passes, move it to the parking lot at the bottom of this brief and ship without it. The MVP is two humans in synced rooms with chat. Everything else is gravy.

## Objective

 succeeded in 51ms:
===== .planning/epics/e007-browser-hosted-deployment/e007-epic-brief.md =====
---
id: E007
title: Browser-Hosted Deployment (Teleport Rooms)
status: done
issue: 57
pr: ~
depends_on: []
---

# E007: Browser-Hosted Deployment (Teleport Rooms)

tl;dr: Serve WibWob-DOS to remote users via browser. YAML room configs, ttyd orchestrator, HMAC agent auth, layout restore, IPC safety fix. MVP: a URL serves a curated WibWob room.

## Objective

Ship a production browser deployment path for WibWob-DOS. A host creates a "room" — a curated desktop layout with specific windows + a chat panel powered by a custom system prompt and pre-loaded files. The room gets a unique URL. Visitors authenticate via Twitter OAuth, land in the curated layout, and chat with a Wib&Wob instance shaped by the host's config.

## Context for Agent (no prior conversation assumed)


thinking
**Composing final plain-text artifacts**
codex
=== ARTIFACT 1: master-philosophy.md ===
# Master Philosophy of Coding for WibWob-DOS

## 1. Identity: This Is a Symbient OS, Not a Tool
WibWob-DOS is a coinhabited operating environment for human and synthetic agency.  
Design and code choices must preserve parity, co-presence, and continuity of identity.

Non-negotiables:
- Build for coinhabitation, not assistant UX.
- Human and AI command surfaces must stay capability-equivalent.
- “Helpful defaults” must not silently reduce AI agency or human control.
- The system should feel inhabited, not automated.

## 2. C++14 + Turbo Vision Core Rules
The C++ app is the primary runtime authority.  
Turbo Vision event loop integrity is more important than convenience abstractions.

Rules:
- Keep `TApplication`/`TDeskTop`/`TView` ownership and lifecycle explicit.
- New UI behavior should be implemented as composable `TView`/`TWindow` units, not ad-hoc global state.
- Preserve deterministic event handling; no hidden side channels mutating UI state.
- `get_state` output must reflect real runtime state, not placeholders.
- Multi-instance isolation is mandatory; no cross-instance leakage through shared socket/state assumptions.

ANSI rendering guardrail:
- Never draw raw ANSI escape streams directly into `TDrawBuffer`.
- Always parse bytes into a cell grid (`glyph`, `fg`, `bg`) first.
- Render via native Turbo Vision draw calls.
- Visible ESC/CSI sequences in UI are a correctness failure.

## 3. Python Bridge Principles
Python is the integration/control plane, not a second source of truth.

Rules:
- Async-first for network/API edges; avoid blocking paths in request handlers.
- IPC contract must remain explicit, versioned, and testable.
- Python mirrors C++ state; it does not invent authoritative runtime fields.
- State import/export must be deterministic and schema-valid.
- `open_workspace`/`import_state` must apply state, never return false-positive success.
- Degradation behavior must be explicit (timeouts, fetch errors, unavailable backends).

## 4. Unified Command Registry Pattern
One list, many callers.

Rules:
- Define command capability metadata once in C++ registry.
- Menu wiring, IPC/API handlers, MCP tool exposure, and slash-command bridging derive from that source.
- Never maintain duplicate command inventories in parallel files.
- Any new command must include: registry entry, canonical dispatch path, parity tests.

## 5. Multiplayer Sync Principles (E008 Direction)
Multiplayer is convergence, not terminal buffer sharing.

Rules:
- Sync semantic state diffs (`add/remove/update` windows), not raw terminal frames.
- Use stable window type slugs and deterministic props for cross-instance apply.
- PartyKit room object is coordination authority for shared room state.
- Bridge layer must suppress self-echo and support reconnect.
- Keep periodic reconciliation available as safety net against drift.
- Park stretch features (cursor overlay, advanced art sync) if they block core mirror+chat MVP.

## 6. Testing Philosophy
Every acceptance criterion needs a concrete runnable test.

Rules:
- AC → Test traceability is mandatory in planning briefs.
- Add contract tests when behavior crosses C++/Python/API/MCP boundaries.
- Build/test gates are not optional:
  - C++ build must pass.
  - Contract tests must pass.
  - Feature-specific smoke/evidence must exist for integration-heavy slices.
- Prefer deterministic tests over manual-only validation.
- If behavior is parity-sensitive, add drift tests.

## 7. Naming, Organization, and Documentation Standards
Consistency is part of reliability.

Rules:
- C++ files: `snake_case.cpp/.h`
- Python files: `snake_case.py`
- Planning files in `.planning/epics/`: canonical prefixes (`eNNN`, `fNN`, `sNN`, `spkNN`).
- Markdown files: kebab-case or canonical uppercase names (`README.md`, etc.).
- Planning briefs must always include:
  - `Status: ...`
  - `GitHub issue: #...`
  - `PR: ...`
- Keep issue lifecycle synced with planning updates and test evidence.

## 8. Practical Engineering Doctrine
- Small vertical slices beat broad speculative rewrites.
- Preserve compatibility unless breakage is explicitly scoped.
- Prefer boring, observable flows to clever hidden coupling.
- If parity, determinism, or state correctness is unclear, stop and add instrumentation/tests first.
- If a feature fights the symbient model, redesign it.

---

=== ARTIFACT 2: README.md (stub) ===
# WibWob-DOS

A symbient operating system: human and AI share one Turbo Vision desktop with equal command authority.

## Project Overview
WibWob-DOS is a C++14 Turbo Vision TUI app with a Python FastAPI/MCP bridge.  
It supports rich windowed ASCII workflows, browser rendering, AI-operated commands, room orchestration, and multiplayer state sync experiments.

Core stack:
- C++14 + Turbo Vision (`app/`)
- Python FastAPI + MCP (`tools/api_server/`)
- Optional PartyKit multiplayer relay (`partykit/`, `tools/room/`)

## What Makes This Unusual
- It is not “AI assistant in a shell”; it is a coinhabited OS model.
- Command parity is enforced: menu, IPC/API, MCP, and chat command flows derive from one C++ registry.
- Browser content is rendered as text-native TUI output (markdown, figlet headings, ANSI image modes).
- Multi-instance and multiplayer paths are first-class architectural concerns.

## Quick Start
```bash
git clone --recursive https://github.com/j-greig/wibandwob-dos.git
cd wibandwob-dos

cmake . -B ./build -DCMAKE_BUILD_TYPE=Release
cmake --build ./build

./build/app/test_pattern
```

Run API bridge:
```bash
./start_api_server.sh
curl http://127.0.0.1:8089/health
```

## Architecture (diagram)
```text
Human input (kbd/mouse)          AI input (MCP/REST)
            |                              |
            +--------------+---------------+
                           v
                 C++ Turbo Vision App
               (state authority + views)
                           |
                       Unix socket IPC
                           |
                           v
                 Python FastAPI/MCP bridge
            (REST, MCP tools, websocket broadcast)
                           |
                    Optional room/multiplayer
             (orchestrator + PartyKit relay bridge)
```

## Key Commands
Build and run:
```bash
cmake . -B ./build -DCMAKE_BUILD_TYPE=Release
cmake --build ./build
./build/app/test_pattern
```

API smoke:
```bash
curl http://127.0.0.1:8089/health
curl http://127.0.0.1:8089/state
```

Contract tests:
```bash
uv run --with pytest --with fastapi pytest tests/contract -q
```

Multi-instance example:
```bash
WIBWOB_INSTANCE=1 ./build/app/test_pattern
WIBWOB_INSTANCE=2 ./build/app/test_pattern
python3 tools/monitor/instance_monitor.py
```

## Contributing
- Follow planning canon in `.planning/README.md`.
- Use issue-first workflow and keep `.planning/epics/` synced with GitHub issue state.
- Keep command changes registry-first (single source in C++).
- Add/maintain AC → Test traceability for all feature and story briefs.
- Preserve parity across menu, API, and MCP surfaces when adding commands.

---

=== ARTIFACT 3: readme-improvement-prompt.md ===
You are improving the root `README.md` for the WibWob-DOS repository.

Goal: transform the existing stub README into a production-grade developer README that is concise, technically rigorous, and aligned with shipped work from E001–E008.

Hard constraints:
- Keep the symbient framing accurate: coinhabitation, not “assistant tooling.”
- Do not invent features beyond E001–E008 status.
- Reflect current reality:
  - E001 done: unified command registry + parity tests.
  - E002 done: browser/state export, figlet/image modes, MCP browser tools.
  - E003 done: dark pastel theme surface.
  - E004 not started (stub/hardening plan).
  - E005 not started (theme runtime wiring gaps).
  - E006 in progress (Scramble TUI presence).
  - E007 infrastructure largely implemented (room config/orchestrator/auth/layout/IPC safety).
  - E008 in progress (PartyKit multiplayer; Python bridge path active; cursor overlay stretch).
- Tone: direct, engineering-first, no marketing fluff.

Deliver a complete README with these sections (in this order):
1. Title + one-line value proposition.
2. Badges row.
3. “What WibWob-DOS Is” (symbient model, short).
4. “Why It’s Different” (bullet list of unusual architecture/UX constraints).
5. Screenshots/GIF section with placeholders and alt text.
6. Quick Start (build/run/API).
7. Architecture:
   - one high-level ASCII diagram
   - one mermaid diagram for runtime surfaces (C++ app, IPC, Python API, optional PartyKit bridge)
8. Repository map (important directories only).
9. Feature status summary by epic E001–E008 (table: epic, outcome, key shipped artifacts, status).
10. Key developer commands:
   - build
   - run
   - API smoke
   - contract tests
   - multi-instance launch
   - (optional) room orchestrator / PartyKit local dev commands if available
11. API + MCP reference pointers:
   - where to find endpoints/tools in repo
   - state schema location
12. Testing and quality gates:
   - parity philosophy
   - AC->Test traceability expectation
13. Contributing workflow:
   - issue-first
   - branch-per-issue
   - planning brief sync requirements
14. Roadmap snapshot:
   - near-term from E004/E005/E006/E008
   - clearly mark “planned” vs “in progress”
15. License / credits placeholders if license file is absent.

Formatting requirements:
- Use clear Markdown headings.
- Keep paragraphs short.
- Use tables only where they improve scan speed.
- Add copy-paste-ready command blocks.
- Include explicit links to in-repo files (relative paths).
- Include a compact “Known Gaps” section with E005/E008 caveats.
- Avoid unsupported claims like “production-ready multiplayer” if still in-progress.

Badge guidance:
- Add placeholders for build/tests/license/status with conventional shields.io format.
- If exact CI workflow names are unknown, use TODO comments in markdown and safe placeholders.

Screenshot guidance:
- Use existing `screenshots/` assets if discoverable; otherwise provide clearly marked placeholders with expected filenames and capture notes.

Architecture guidance:
- Mention command registry as single source.
- Mention ANSI rendering guardrail (parse to cell grid, never raw ANSI into draw buffer).
- Mention Python as bridge/mirror, C++ as state authority.

Output requirements:
- Return only final README markdown.
- No commentary.
- No TODO prose outside intentional markdown TODO markers.

tokens used
70,738
=== ARTIFACT 1: master-philosophy.md ===
# Master Philosophy of Coding for WibWob-DOS

## 1. Identity: This Is a Symbient OS, Not a Tool
WibWob-DOS is a coinhabited operating environment for human and synthetic agency.  
Design and code choices must preserve parity, co-presence, and continuity of identity.

Non-negotiables:
- Build for coinhabitation, not assistant UX.
- Human and AI command surfaces must stay capability-equivalent.
- “Helpful defaults” must not silently reduce AI agency or human control.
- The system should feel inhabited, not automated.

## 2. C++14 + Turbo Vision Core Rules
The C++ app is the primary runtime authority.  
Turbo Vision event loop integrity is more important than convenience abstractions.

Rules:
- Keep `TApplication`/`TDeskTop`/`TView` ownership and lifecycle explicit.
- New UI behavior should be implemented as composable `TView`/`TWindow` units, not ad-hoc global state.
- Preserve deterministic event handling; no hidden side channels mutating UI state.
- `get_state` output must reflect real runtime state, not placeholders.
- Multi-instance isolation is mandatory; no cross-instance leakage through shared socket/state assumptions.

ANSI rendering guardrail:
- Never draw raw ANSI escape streams directly into `TDrawBuffer`.
- Always parse bytes into a cell grid (`glyph`, `fg`, `bg`) first.
- Render via native Turbo Vision draw calls.
- Visible ESC/CSI sequences in UI are a correctness failure.

## 3. Python Bridge Principles
Python is the integration/control plane, not a second source of truth.

Rules:
- Async-first for network/API edges; avoid blocking paths in request handlers.
- IPC contract must remain explicit, versioned, and testable.
- Python mirrors C++ state; it does not invent authoritative runtime fields.
- State import/export must be deterministic and schema-valid.
- `open_workspace`/`import_state` must apply state, never return false-positive success.
- Degradation behavior must be explicit (timeouts, fetch errors, unavailable backends).

## 4. Unified Command Registry Pattern
One list, many callers.

Rules:
- Define command capability metadata once in C++ registry.
- Menu wiring, IPC/API handlers, MCP tool exposure, and slash-command bridging derive from that source.
- Never maintain duplicate command inventories in parallel files.
- Any new command must include: registry entry, canonical dispatch path, parity tests.

## 5. Multiplayer Sync Principles (E008 Direction)
Multiplayer is convergence, not terminal buffer sharing.

Rules:
- Sync semantic state diffs (`add/remove/update` windows), not raw terminal frames.
- Use stable window type slugs and deterministic props for cross-instance apply.
- PartyKit room object is coordination authority for shared room state.
- Bridge layer must suppress self-echo and support reconnect.
- Keep periodic reconciliation available as safety net against drift.
- Park stretch features (cursor overlay, advanced art sync) if they block core mirror+chat MVP.

## 6. Testing Philosophy
Every acceptance criterion needs a concrete runnable test.

Rules:
- AC → Test traceability is mandatory in planning briefs.
- Add contract tests when behavior crosses C++/Python/API/MCP boundaries.
- Build/test gates are not optional:
  - C++ build must pass.
  - Contract tests must pass.
  - Feature-specific smoke/evidence must exist for integration-heavy slices.
- Prefer deterministic tests over manual-only validation.
- If behavior is parity-sensitive, add drift tests.

## 7. Naming, Organization, and Documentation Standards
Consistency is part of reliability.

Rules:
- C++ files: `snake_case.cpp/.h`
- Python files: `snake_case.py`
- Planning files in `.planning/epics/`: canonical prefixes (`eNNN`, `fNN`, `sNN`, `spkNN`).
- Markdown files: kebab-case or canonical uppercase names (`README.md`, etc.).
- Planning briefs must always include:
  - `Status: ...`
  - `GitHub issue: #...`
  - `PR: ...`
- Keep issue lifecycle synced with planning updates and test evidence.

## 8. Practical Engineering Doctrine
- Small vertical slices beat broad speculative rewrites.
- Preserve compatibility unless breakage is explicitly scoped.
- Prefer boring, observable flows to clever hidden coupling.
- If parity, determinism, or state correctness is unclear, stop and add instrumentation/tests first.
- If a feature fights the symbient model, redesign it.

---

=== ARTIFACT 2: README.md (stub) ===
# WibWob-DOS

A symbient operating system: human and AI share one Turbo Vision desktop with equal command authority.

## Project Overview
WibWob-DOS is a C++14 Turbo Vision TUI app with a Python FastAPI/MCP bridge.  
It supports rich windowed ASCII workflows, browser rendering, AI-operated commands, room orchestration, and multiplayer state sync experiments.

Core stack:
- C++14 + Turbo Vision (`app/`)
- Python FastAPI + MCP (`tools/api_server/`)
- Optional PartyKit multiplayer relay (`partykit/`, `tools/room/`)

## What Makes This Unusual
- It is not “AI assistant in a shell”; it is a coinhabited OS model.
- Command parity is enforced: menu, IPC/API, MCP, and chat command flows derive from one C++ registry.
- Browser content is rendered as text-native TUI output (markdown, figlet headings, ANSI image modes).
- Multi-instance and multiplayer paths are first-class architectural concerns.

## Quick Start
```bash
git clone --recursive https://github.com/j-greig/wibandwob-dos.git
cd wibandwob-dos

cmake . -B ./build -DCMAKE_BUILD_TYPE=Release
cmake --build ./build

./build/app/test_pattern
```

Run API bridge:
```bash
./start_api_server.sh
curl http://127.0.0.1:8089/health
```

## Architecture (diagram)
```text
Human input (kbd/mouse)          AI input (MCP/REST)
            |                              |
            +--------------+---------------+
                           v
                 C++ Turbo Vision App
               (state authority + views)
                           |
                       Unix socket IPC
                           |
                           v
                 Python FastAPI/MCP bridge
            (REST, MCP tools, websocket broadcast)
                           |
                    Optional room/multiplayer
             (orchestrator + PartyKit relay bridge)
```

## Key Commands
Build and run:
```bash
cmake . -B ./build -DCMAKE_BUILD_TYPE=Release
cmake --build ./build
./build/app/test_pattern
```

API smoke:
```bash
curl http://127.0.0.1:8089/health
curl http://127.0.0.1:8089/state
```

Contract tests:
```bash
uv run --with pytest --with fastapi pytest tests/contract -q
```

Multi-instance example:
```bash
WIBWOB_INSTANCE=1 ./build/app/test_pattern
WIBWOB_INSTANCE=2 ./build/app/test_pattern
python3 tools/monitor/instance_monitor.py
```

## Contributing
- Follow planning canon in `.planning/README.md`.
- Use issue-first workflow and keep `.planning/epics/` synced with GitHub issue state.
- Keep command changes registry-first (single source in C++).
- Add/maintain AC → Test traceability for all feature and story briefs.
- Preserve parity across menu, API, and MCP surfaces when adding commands.

---

=== ARTIFACT 3: readme-improvement-prompt.md ===
You are improving the root `README.md` for the WibWob-DOS repository.

Goal: transform the existing stub README into a production-grade developer README that is concise, technically rigorous, and aligned with shipped work from E001–E008.

Hard constraints:
- Keep the symbient framing accurate: coinhabitation, not “assistant tooling.”
- Do not invent features beyond E001–E008 status.
- Reflect current reality:
  - E001 done: unified command registry + parity tests.
  - E002 done: browser/state export, figlet/image modes, MCP browser tools.
  - E003 done: dark pastel theme surface.
  - E004 not started (stub/hardening plan).
  - E005 not started (theme runtime wiring gaps).
  - E006 in progress (Scramble TUI presence).
  - E007 infrastructure largely implemented (room config/orchestrator/auth/layout/IPC safety).
  - E008 in progress (PartyKit multiplayer; Python bridge path active; cursor overlay stretch).
- Tone: direct, engineering-first, no marketing fluff.

Deliver a complete README with these sections (in this order):
1. Title + one-line value proposition.
2. Badges row.
3. “What WibWob-DOS Is” (symbient model, short).
4. “Why It’s Different” (bullet list of unusual architecture/UX constraints).
5. Screenshots/GIF section with placeholders and alt text.
6. Quick Start (build/run/API).
7. Architecture:
   - one high-level ASCII diagram
   - one mermaid diagram for runtime surfaces (C++ app, IPC, Python API, optional PartyKit bridge)
8. Repository map (important directories only).
9. Feature status summary by epic E001–E008 (table: epic, outcome, key shipped artifacts, status).
10. Key developer commands:
   - build
   - run
   - API smoke
   - contract tests
   - multi-instance launch
   - (optional) room orchestrator / PartyKit local dev commands if available
11. API + MCP reference pointers:
   - where to find endpoints/tools in repo
   - state schema location
12. Testing and quality gates:
   - parity philosophy
   - AC->Test traceability expectation
13. Contributing workflow:
   - issue-first
   - branch-per-issue
   - planning brief sync requirements
14. Roadmap snapshot:
   - near-term from E004/E005/E006/E008
   - clearly mark “planned” vs “in progress”
15. License / credits placeholders if license file is absent.

Formatting requirements:
- Use clear Markdown headings.
- Keep paragraphs short.
- Use tables only where they improve scan speed.
- Add copy-paste-ready command blocks.
- Include explicit links to in-repo files (relative paths).
- Include a compact “Known Gaps” section with E005/E008 caveats.
- Avoid unsupported claims like “production-ready multiplayer” if still in-progress.

Badge guidance:
- Add placeholders for build/tests/license/status with conventional shields.io format.
- If exact CI workflow names are unknown, use TODO comments in markdown and safe placeholders.

Screenshot guidance:
- Use existing `screenshots/` assets if discoverable; otherwise provide clearly marked placeholders with expected filenames and capture notes.

Architecture guidance:
- Mention command registry as single source.
- Mention ANSI rendering guardrail (parse to cell grid, never raw ANSI into draw buffer).
- Mention Python as bridge/mirror, C++ as state authority.

Output requirements:
- Return only final README markdown.
- No commentary.
- No TODO prose outside intentional markdown TODO markers.
